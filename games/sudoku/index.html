<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Ellen's Sudoku</title>
<style>
  :root {
    --cell-size: min(40px, 9vw);
    --border-color: #394457;
    --bg-color: #f5f5f5;
    --fixed-bg: #e2e8f0;
    --button-bg: #3b82f6;
    --button-hover: #2563eb;
  }
  
  * { box-sizing: border-box; }
  
  body { 
    font-family: system-ui, -apple-system, Arial, sans-serif; 
    text-align: center; 
    background: var(--bg-color);
    margin: 0;
    padding: 16px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  
  h1 { 
    margin: 16px 0;
    font-size: clamp(24px, 5vw, 32px);
  }
  
  .controls {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
    margin-bottom: 16px;
    width: 100%;
    max-width: 400px;
  }
  
  button { 
    flex: 1;
    min-width: 120px;
    padding: 12px;
    font-size: 16px;
    border: none;
    border-radius: 8px;
    background: var(--button-bg);
    color: white;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  button:hover {
    background: var(--button-hover);
  }
  
  table { 
    border-collapse: collapse; 
    margin: 0 auto;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  
  td {
    border: 1px solid #ddd;
    width: var(--cell-size); 
    height: var(--cell-size);
    text-align: center;
    position: relative;
    padding: 0;
  }
  
  input {
    width: 100%;
    height: 100%;
    text-align: center;
    font-size: calc(var(--cell-size) * 0.5);
    border: none;
    padding: 0;
    background: transparent;
    appearance: none;
    -webkit-appearance: none;
  }
  
  input:focus {
    outline: 2px solid var(--button-bg);
    outline-offset: -2px;
  }
  
  .fixed { 
    background: var(--fixed-bg); 
    font-weight: 600;
  }
  
  /* Style for revealed answer numbers */
  .revealed-answer {
    color: #2563eb;  /* 蓝色答案 */
    font-weight: 500;
    font-style: italic;
    background: #eff6ff;  /* 淡蓝色背景 */
  }
  
  /* Style for incorrect numbers */
  .incorrect {
    color: #dc2626;  /* 红色错误数字 */
    background: #fef2f2;  /* 淡红色背景 */
    position: relative;
  }
  
  .incorrect::after {
    content: '×';
    position: absolute;
    top: -8px;
    right: 0;
    font-size: 12px;
    color: #dc2626;
    font-weight: bold;
  }
  
  /* Selected cell highlighting */
  .selected {
    background: #e0f2fe !important;
    outline: 3px solid var(--button-bg) !important;
    outline-offset: -3px;
  }
  
  /* Number panel styles */
  .number-panel {
    margin: 20px auto;
    max-width: 500px;
    padding: 16px;
    background: white;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  
  .panel-title {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 12px;
    color: #374151;
    text-align: center;
  }
  
  .number-buttons {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 8px;
    max-width: 400px;
    margin: 0 auto;
  }
  
  .number-btn {
    width: 50px;
    height: 50px;
    border: 2px solid #e5e7eb;
    border-radius: 8px;
    background: #f9fafb;
    color: #374151;
    font-size: 18px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: auto;
    padding: 0;
  }
  
  .number-btn:hover {
    background: #e5e7eb;
    border-color: var(--button-bg);
    transform: translateY(-1px);
  }
  
  .number-btn:active {
    transform: translateY(0);
  }
  
  .clear-btn {
    background: #fee2e2;
    border-color: #fca5a5;
    color: #dc2626;
  }
  
  .clear-btn:hover {
    background: #fecaca;
    border-color: #f87171;
  }
  
  /* Difficulty selector styles */
  .difficulty-selector {
    margin: 16px auto;
    max-width: 600px;
    padding: 16px;
    background: white;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  
  .difficulty-title {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 12px;
    color: #374151;
    text-align: center;
  }
  
  .difficulty-buttons {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
  }
  
  .difficulty-btn {
    padding: 16px 12px;
    border: 2px solid #e5e7eb;
    border-radius: 12px;
    background: #f9fafb;
    color: #374151;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    min-width: auto;
    font-size: 14px;
  }
  
  .difficulty-btn:hover {
    background: #f3f4f6;
    border-color: var(--button-bg);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }
  
  .difficulty-btn.active {
    background: var(--button-bg);
    border-color: var(--button-bg);
    color: white;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
  }
  
  .difficulty-btn.active:hover {
    background: var(--button-hover);
    border-color: var(--button-hover);
  }
  
  .level-name {
    font-weight: 600;
    font-size: 16px;
  }
  
  .level-desc {
    font-size: 12px;
    opacity: 0.8;
  }
  
  /* Notes mode selector styles */
  .notes-mode-selector {
    margin: 16px auto;
    max-width: 200px;
    display: flex;
    justify-content: center;
  }
  
  .notes-toggle-btn {
    padding: 12px 20px;
    border: 2px solid #e5e7eb;
    border-radius: 12px;
    background: #f9fafb;
    color: #374151;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    font-size: 14px;
    font-weight: 500;
    min-width: 120px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  
  .notes-toggle-btn:hover {
    background: #f3f4f6;
    border-color: #9ca3af;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  }
  
  .notes-toggle-btn.active {
    background: var(--button-bg);
    border-color: var(--button-bg);
    color: white;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    transform: translateY(-1px);
  }
  
  .notes-toggle-btn.active:hover {
    background: var(--button-hover);
    border-color: var(--button-hover);
    box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
  }
  
  .mode-icon {
    font-size: 16px;
    transition: transform 0.2s;
  }
  
  .notes-toggle-btn.active .mode-icon {
    transform: scale(1.1);
  }
  
  .mode-name {
    font-weight: 500;
  }
  
  /* Notes grid styles */
  .notes-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    width: 100%;
    height: 100%;
    gap: 1px;
    padding: 2px;
    box-sizing: border-box;
  }
  
  .notes-cell {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 500;
    color: #666;
    background: transparent;
    min-height: 0;
    line-height: 1;
  }
  
  .notes-cell.filled {
    color: #2563eb;
    font-weight: 600;
  }
  
  /* Hide regular input when in notes mode */
  .cell-notes .regular-input {
    display: none;
  }
  
  /* Show notes grid only when cell has notes */
  .cell-notes .notes-grid {
    display: grid;
  }
  
  .cell-regular .notes-grid {
    display: none;
  }
  
  .thick-right { 
    border-right: 3px solid var(--border-color); 
  }
  
  .thick-bottom { 
    border-bottom: 3px solid var(--border-color); 
  }
  
  #message {
    margin: 16px 0;
    min-height: 24px;
    font-size: 16px;
  }
  
  @media (max-width: 480px) {
    body {
      padding: 8px;
    }
    
    .controls {
      padding: 0 8px;
    }
    
    button {
      padding: 10px;
      min-width: 100px;
      font-size: 14px;
    }
    
    input {
      font-size: calc(var(--cell-size) * 0.6);
    }
    
    .number-panel {
      margin: 16px auto;
      padding: 12px;
    }
    
    .number-buttons {
      grid-template-columns: repeat(5, 1fr);
      gap: 6px;
    }
    
    .number-btn {
      width: 45px;
      height: 45px;
      font-size: 16px;
    }
    
    .panel-title {
      font-size: 14px;
    }
    
    .difficulty-selector {
      margin: 12px auto;
      padding: 12px;
    }
    
    .difficulty-buttons {
      grid-template-columns: 1fr;
      gap: 8px;
    }
    
    .difficulty-btn {
      padding: 12px;
      flex-direction: row;
      justify-content: space-between;
    }
    
    .difficulty-title {
      font-size: 14px;
    }
    
    .notes-mode-selector {
      margin: 12px auto;
      max-width: 180px;
    }
    
    .notes-toggle-btn {
      padding: 10px 16px;
      font-size: 13px;
      gap: 6px;
      min-width: 100px;
    }
    
    .mode-icon {
      font-size: 14px;
    }
    
    .notes-cell {
      font-size: 8px;
    }
  }
  
  @media (min-width: 768px) {
    :root {
      --cell-size: 44px;
    }
  }
</style>
</head>
<body>
<h1>9×9 Sudoku Game</h1>
<div class="controls">
  <button onclick="generateSudoku()">New Game</button>
  <button onclick="checkSudoku()">Check Answer</button>
  <button onclick="revealAnswer()">Peek Answer</button>
</div>

<div class="difficulty-selector">
  <div class="difficulty-title">Difficulty Level:</div>
  <div class="difficulty-buttons">
    <button class="difficulty-btn active" onclick="setDifficulty('easy')" data-level="easy">
      <span class="level-name">Easy</span>
      <span class="level-desc">40-45 clues</span>
    </button>
    <button class="difficulty-btn" onclick="setDifficulty('medium')" data-level="medium">
      <span class="level-name">Medium</span>
      <span class="level-desc">30-35 clues</span>
    </button>
    <button class="difficulty-btn" onclick="setDifficulty('hard')" data-level="hard">
      <span class="level-name">Hard</span>
      <span class="level-desc">25-30 clues</span>
    </button>
  </div>
</div>
<table id="sudoku"></table>
<p id="message"></p>

<div class="notes-mode-selector">
  <button class="notes-toggle-btn" onclick="toggleNotesMode()" id="notes-toggle">
    <span class="mode-icon">📝</span>
    <span class="mode-name">Notes</span>
  </button>
</div>

<div class="number-panel">
  <div class="panel-title">Select Number:</div>
  <div class="number-buttons">
    <button class="number-btn" onclick="fillNumber(1)">1</button>
    <button class="number-btn" onclick="fillNumber(2)">2</button>
    <button class="number-btn" onclick="fillNumber(3)">3</button>
    <button class="number-btn" onclick="fillNumber(4)">4</button>
    <button class="number-btn" onclick="fillNumber(5)">5</button>
    <button class="number-btn" onclick="fillNumber(6)">6</button>
    <button class="number-btn" onclick="fillNumber(7)">7</button>
    <button class="number-btn" onclick="fillNumber(8)">8</button>
    <button class="number-btn" onclick="fillNumber(9)">9</button>
    <button class="number-btn clear-btn" onclick="fillNumber(0)">✕</button>
  </div>
</div>

<script>
function createEmptyBoard() {
  return Array.from({ length: 9 }, () => Array(9).fill(0));
}

function isSafe(board, row, col, num) {
  for (let i = 0; i < 9; i++) {
    if (board[row][i] === num || board[i][col] === num) return false;
  }
  let startRow = Math.floor(row / 3) * 3;
  let startCol = Math.floor(col / 3) * 3;
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      if (board[startRow + r][startCol + c] === num) return false;
    }
  }
  return true;
}

function solveBoard(board) {
  for (let row = 0; row < 9; row++) {
    for (let col = 0; col < 9; col++) {
      if (board[row][col] === 0) {
        let nums = [1,2,3,4,5,6,7,8,9];
        nums.sort(() => Math.random() - 0.5);
        for (let num of nums) {
          if (isSafe(board, row, col, num)) {
            board[row][col] = num;
            if (solveBoard(board)) return true;
            board[row][col] = 0;
          }
        }
        return false;
      }
    }
  }
  return true;
}

function generateFullSudoku() {
  let board = createEmptyBoard();
  solveBoard(board);
  return board;
}

function generatePuzzle(fullBoard, clues = 35) {
  let puzzle = fullBoard.map(row => row.slice());
  let removeCount = 81 - clues;
  while (removeCount > 0) {
    let r = Math.floor(Math.random() * 9);
    let c = Math.floor(Math.random() * 9);
    if (puzzle[r][c] !== 0) {
      puzzle[r][c] = 0;
      removeCount--;
    }
  }
  return puzzle;
}

let solutionBoard = null;
let puzzleBoard = null;
let selectedCell = null; // Track selected cell {row, col}
let currentDifficulty = 'easy'; // Current difficulty level
let isNotesMode = false; // Notes mode state
let notesBoard = null; // Store notes for each cell

// Difficulty settings
const difficultySettings = {
  easy: { clues: 42, name: 'Easy' },
  medium: { clues: 32, name: 'Medium' },
  hard: { clues: 27, name: 'Hard' }
};

// Initialize notes board
function initNotesBoard() {
  notesBoard = Array.from({ length: 9 }, () => 
    Array.from({ length: 9 }, () => new Set())
  );
}

function renderBoard(puzzle) {
  const table = document.getElementById('sudoku');
  table.innerHTML = '';
  selectedCell = null; // Reset selection
  
  for (let r = 0; r < 9; r++) {
    let tr = document.createElement('tr');
    for (let c = 0; c < 9; c++) {
      let td = document.createElement('td');
      if ((c+1) % 3 === 0 && c < 8) td.classList.add('thick-right');
      if ((r+1) % 3 === 0 && r < 8) td.classList.add('thick-bottom');

      if (puzzle[r][c] !== 0) {
        // Fixed cell - only show the number
        td.innerHTML = `<input type="text" value="${puzzle[r][c]}" readonly class="fixed regular-input">`;
      } else {
        // Empty cell - support both regular input and notes
        const hasNotes = notesBoard && notesBoard[r][c] && notesBoard[r][c].size > 0;
        const cellClass = hasNotes ? 'cell-notes' : 'cell-regular';
        
        td.classList.add(cellClass);
        td.innerHTML = `
          <input type="text" onclick="selectCell(${r}, ${c})" class="regular-input" maxlength="1" onkeydown="return false;">
          <div class="notes-grid">
            ${renderNotesGrid(r, c)}
          </div>
        `;
      }
      tr.appendChild(td);
    }
    table.appendChild(tr);
  }
}

// Render 3x3 notes grid for a cell
function renderNotesGrid(row, col) {
  let html = '';
  for (let i = 1; i <= 9; i++) {
    const hasNote = notesBoard && notesBoard[row][col] && notesBoard[row][col].has(i);
    const cellClass = hasNote ? 'notes-cell filled' : 'notes-cell';
    const content = hasNote ? i : '';
    html += `<div class="${cellClass}" onclick="toggleNote(${row}, ${col}, ${i})">${content}</div>`;
  }
  return html;
}

// Toggle notes mode
function toggleNotesMode() {
  isNotesMode = !isNotesMode;
  
  // Update button styles
  const toggleBtn = document.getElementById('notes-toggle');
  if (isNotesMode) {
    toggleBtn.classList.add('active');
  } else {
    toggleBtn.classList.remove('active');
  }
  
  // Re-render board to update cell display states
  if (puzzleBoard) {
    // Save current user inputs before re-rendering
    const table = document.getElementById('sudoku');
    const userInputs = {};
    
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        if (table.rows[r] && table.rows[r].cells[c]) {
          const input = table.rows[r].cells[c].querySelector('input');
          if (input && !input.classList.contains('fixed') && input.value) {
            userInputs[`${r}-${c}`] = input.value;
          }
        }
      }
    }
    
    // Re-render the board
    renderBoard(puzzleBoard);
    
    // Restore user inputs
    const newTable = document.getElementById('sudoku');
    for (const key in userInputs) {
      const [r, c] = key.split('-').map(Number);
      const input = newTable.rows[r].cells[c].querySelector('input');
      if (input && !input.classList.contains('fixed')) {
        input.value = userInputs[key];
      }
    }
    
    // Restore selection state if there was one
    if (selectedCell) {
      const input = newTable.rows[selectedCell.row].cells[selectedCell.col].querySelector('input');
      if (input && !input.classList.contains('fixed')) {
        input.classList.add('selected');
      }
    }
  }
  
  // Show feedback message
  const modeText = isNotesMode ? 'Notes Mode' : 'Normal Mode';
  const icon = isNotesMode ? '📝' : '🔢';
  document.getElementById('message').textContent = `${icon} Switched to ${modeText}`;
  setTimeout(() => {
    document.getElementById('message').textContent = '';
  }, 2000);
}

// Toggle note in a cell (for notes mode)
function toggleNote(row, col, num) {
  if (!isNotesMode) return;
  
  // Don't allow notes on fixed cells
  const table = document.getElementById('sudoku');
  const input = table.rows[row].cells[col].querySelector('input');
  if (input && input.classList.contains('fixed')) return;
  
  // Clear regular number when adding notes
  if (input && input.value) {
    input.value = '';
  }
  
  // Toggle note
  if (!notesBoard[row][col]) {
    notesBoard[row][col] = new Set();
  }
  
  if (notesBoard[row][col].has(num)) {
    notesBoard[row][col].delete(num);
  } else {
    notesBoard[row][col].add(num);
  }
  
  // Re-render the cell
  renderSingleCell(row, col);
}

// Render a single cell (helper function)
function renderSingleCell(row, col) {
  const table = document.getElementById('sudoku');
  const td = table.rows[row].cells[col];
  const puzzle = puzzleBoard;
  
  // Preserve border classes
  const thickRight = td.classList.contains('thick-right');
  const thickBottom = td.classList.contains('thick-bottom');
  
  if (puzzle[row][col] !== 0) {
    // Fixed cell
    td.className = '';
    if (thickRight) td.classList.add('thick-right');
    if (thickBottom) td.classList.add('thick-bottom');
    td.innerHTML = `<input type="text" value="${puzzle[row][col]}" readonly class="fixed regular-input">`;
  } else {
    // Empty cell - support both regular input and notes
    const hasNotes = notesBoard && notesBoard[row][col] && notesBoard[row][col].size > 0;
    const cellClass = hasNotes ? 'cell-notes' : 'cell-regular';
    const isSelected = selectedCell && selectedCell.row === row && selectedCell.col === col;
    
    td.className = '';
    if (thickRight) td.classList.add('thick-right');
    if (thickBottom) td.classList.add('thick-bottom');
    td.classList.add(cellClass);
    td.innerHTML = `
      <input type="text" onclick="selectCell(${row}, ${col})" class="regular-input ${isSelected ? 'selected' : ''}" maxlength="1" onkeydown="return false;">
      <div class="notes-grid">
        ${renderNotesGrid(row, col)}
      </div>
    `;
  }
}

// Set difficulty level
function setDifficulty(level) {
  currentDifficulty = level;
  
  // Update button styles
  document.querySelectorAll('.difficulty-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  document.querySelector(`[data-level="${level}"]`).classList.add('active');
  
  // Show feedback message
  const settings = difficultySettings[level];
  document.getElementById('message').textContent = `🎯 Difficulty set to ${settings.name} (${settings.clues} clues)`;
  setTimeout(() => {
    document.getElementById('message').textContent = '';
  }, 2000);
}

// Handle cell selection
function selectCell(row, col) {
  // Clear previous selection
  document.querySelectorAll('.selected').forEach(cell => {
    cell.classList.remove('selected');
  });
  
  // Select new cell
  const table = document.getElementById('sudoku');
  const cell = table.rows[row].cells[col].querySelector('input');
  
  // Only select if it's not a fixed cell
  if (!cell.classList.contains('fixed')) {
    cell.classList.add('selected');
    selectedCell = { row, col };
  }
}

// Fill number in selected cell
function fillNumber(num) {
  if (!selectedCell) {
    document.getElementById('message').textContent = '⚠️ Please select a cell first!';
    setTimeout(() => {
      document.getElementById('message').textContent = '';
    }, 2000);
    return;
  }
  
  const table = document.getElementById('sudoku');
  const cell = table.rows[selectedCell.row].cells[selectedCell.col].querySelector('input');
  
  // Don't allow editing fixed cells
  if (cell.classList.contains('fixed')) {
    return;
  }
  
  if (isNotesMode) {
    // Notes mode: toggle note
    if (num === 0) {
      // Clear all notes
      if (notesBoard[selectedCell.row][selectedCell.col]) {
        notesBoard[selectedCell.row][selectedCell.col].clear();
      }
    } else {
      // Toggle specific note
      if (!notesBoard[selectedCell.row][selectedCell.col]) {
        notesBoard[selectedCell.row][selectedCell.col] = new Set();
      }
      
      if (notesBoard[selectedCell.row][selectedCell.col].has(num)) {
        notesBoard[selectedCell.row][selectedCell.col].delete(num);
      } else {
        notesBoard[selectedCell.row][selectedCell.col].add(num);
      }
    }
    
    // Clear regular number when adding notes
    cell.value = '';
    cell.classList.remove('incorrect');
    
    // Re-render the cell to show updated notes
    renderSingleCell(selectedCell.row, selectedCell.col);
  } else {
    // Normal mode: fill regular number
    if (num === 0) {
      cell.value = '';
      cell.classList.remove('incorrect');
      // Update cell class when clearing
      const td = cell.parentElement;
      const hasNotes = notesBoard[selectedCell.row][selectedCell.col] && notesBoard[selectedCell.row][selectedCell.col].size > 0;
      if (hasNotes) {
        td.classList.remove('cell-regular');
        td.classList.add('cell-notes');
      } else {
        td.classList.remove('cell-notes');
        td.classList.add('cell-regular');
      }
    } else {
      cell.value = num;
      cell.classList.remove('incorrect');
      
      // Always update cell class when filling regular number
      const td = cell.parentElement;
      
      // Clear notes when filling regular number
      if (notesBoard[selectedCell.row][selectedCell.col]) {
        notesBoard[selectedCell.row][selectedCell.col].clear();
      }
      
      // Always ensure cell is in regular mode when filling number
      td.classList.remove('cell-notes');
      td.classList.add('cell-regular');
    }
  }
  
  // Clear message
  document.getElementById('message').textContent = '';
}

function generateSudoku() {
  const full = generateFullSudoku();
  const clues = difficultySettings[currentDifficulty].clues;
  const puzzle = generatePuzzle(full, clues);
  solutionBoard = full;
  puzzleBoard = puzzle;
  
  // Initialize notes board
  initNotesBoard();
  
  renderBoard(puzzle);
  
  // Show generation message
  const difficultyName = difficultySettings[currentDifficulty].name;
  document.getElementById('message').textContent = `🎮 New ${difficultyName} puzzle generated!`;
  setTimeout(() => {
    document.getElementById('message').textContent = '';
  }, 2000);
  
  // Reset selection state
  selectedCell = null;
  
  // Reset peek answer state
  isShowingAnswer = false;
  originalPuzzle = null;
  const peekButton = document.querySelector('button[onclick="revealAnswer()"]');
  peekButton.textContent = 'Peek Answer';
  peekButton.style.background = '';
  
  // Clear any incorrect marks and selections
  document.querySelectorAll('.incorrect, .selected').forEach(cell => {
    cell.classList.remove('incorrect', 'selected');
  });
}

function checkSudoku() {
  let table = document.getElementById('sudoku');
  let hasError = false;
  let filledCount = 0;
  let totalCells = 81;
  
  // 先清除所有之前的错误标记
  document.querySelectorAll('.incorrect').forEach(cell => {
    cell.classList.remove('incorrect');
  });
  
  // 检查所有已填入的数字
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      let cell = table.rows[r].cells[c].querySelector('input');
      let val = cell.value.trim();
      
      // 跳过空格
      if (!val) continue;
      
      filledCount++;
      val = parseInt(val);
      
      // 检查数字是否正确
      if (val !== solutionBoard[r][c]) {
        cell.classList.add('incorrect');
        hasError = true;
      }
    }
  }
  
  // 更新消息
  const msgEl = document.getElementById('message');
  if (filledCount === 0) {
    msgEl.textContent = '❗ Please fill in some numbers first!';
  } else if (hasError) {
    msgEl.textContent = `❌ Found ${document.querySelectorAll('.incorrect').length} incorrect numbers`;
  } else if (filledCount < totalCells) {
    msgEl.textContent = `✅ All ${filledCount} numbers correct, ${totalCells - filledCount} to go!`;
  } else {
    msgEl.textContent = '🎉 Congratulations, well done!';
  }
}

// Store original puzzle state
let originalPuzzle = null;
let isShowingAnswer = false;

// Toggle between "Peek Answer" and "Continue Game"
function revealAnswer() {
  const table = document.getElementById('sudoku');
  const peekButton = document.querySelector('button[onclick="revealAnswer()"]');
  
  if (!isShowingAnswer) {
    // Save current game state
    originalPuzzle = Array(9).fill().map(() => Array(9).fill(0));
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        let cell = table.rows[r].cells[c].querySelector('input');
        originalPuzzle[r][c] = {
          value: cell.value,
          readOnly: cell.readOnly,
          isFixed: cell.classList.contains('fixed'),
          isSelected: cell.classList.contains('selected')
        };
      }
    }
    
    // Clear selection when showing answer
    selectedCell = null;
    
    // Show answer
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        let cell = table.rows[r].cells[c].querySelector('input');
        // 如果不是原始数字，使用特殊样式显示答案
        if (!cell.classList.contains('fixed')) {
          cell.value = solutionBoard[r][c];
          cell.classList.add('revealed-answer');
          cell.classList.remove('selected', 'incorrect');
        }
      }
    }
    document.getElementById('message').textContent = '🔍 Answer revealed!';
    peekButton.textContent = 'Continue';
    peekButton.style.background = 'var(--button-hover)';
  } else {
    // Restore original game state
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        let cell = table.rows[r].cells[c].querySelector('input');
        let original = originalPuzzle[r][c];
        cell.value = original.value;
        cell.classList.remove('revealed-answer');
        if (original.isSelected) {
          cell.classList.add('selected');
          selectedCell = { row: r, col: c };
        }
        if (!original.isFixed) {
          cell.classList.remove('fixed');
        }
      }
    }
    document.getElementById('message').textContent = '';
    peekButton.textContent = 'Peek Answer';
    peekButton.style.background = '';
  }
  
  isShowingAnswer = !isShowingAnswer;
}

// Initialize the game
initNotesBoard();
generateSudoku();
</script>
</body>
</html>


