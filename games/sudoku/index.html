<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>Ellen's Sudoku</title>
<style>
  :root {
    --cell-size: min(40px, 9vw);
    --border-color: #394457;
    --bg-color: #f5f5f5;
    --fixed-bg: #e2e8f0;
    --button-bg: #3b82f6;
    --button-hover: #2563eb;
  }
  
  * { box-sizing: border-box; }
  
  body { 
    font-family: system-ui, -apple-system, Arial, sans-serif; 
    text-align: center; 
    background: var(--bg-color);
    margin: 0;
    padding: 16px;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  
  h1 { 
    margin: 16px 0;
    font-size: clamp(24px, 5vw, 32px);
  }
  
  .controls-container {
    width: 100%;
    max-width: 600px;
    margin-bottom: 16px;
  }

  .controls {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
    margin-bottom: 12px;
  }

  .game-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    background: linear-gradient(135deg, #f8fafc, #e2e8f0);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    border: 2px solid #e5e7eb;
  }

  .difficulty-dropdown {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
  }

  .difficulty-dropdown label {
    font-weight: 600;
    color: #374151;
    white-space: nowrap;
  }

  .difficulty-dropdown select {
    padding: 6px 12px;
    border: 2px solid #d1d5db;
    border-radius: 8px;
    background: white;
    font-size: 14px;
    color: #374151;
    cursor: pointer;
    transition: border-color 0.2s;
  }

  .difficulty-dropdown select:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
  }

  .score-display {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 16px;
    font-weight: 600;
  }

  .score-label {
    color: #374151;
  }

  .score-value {
    color: #059669;
    font-size: 18px;
    font-weight: 700;
  }

  .multiplier-text {
    color: #7c3aed;
    font-size: 14px;
  }

  .timer-display {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .timer-section {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 16px;
    font-weight: 600;
  }

  .timer-label {
    color: #374151;
  }

  .timer-value {
    color: #dc2626;
    font-size: 18px;
    font-weight: 700;
    font-family: 'Courier New', monospace;
    min-width: 50px;
  }

  .pause-btn {
    padding: 6px 8px;
    border: 2px solid #d1d5db;
    border-radius: 8px;
    background: white;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    min-width: 36px;
    height: 36px;
  }

  .pause-btn:hover {
    background: #f3f4f6;
    border-color: #9ca3af;
    transform: translateY(-1px);
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  }

  .pause-btn:active {
    transform: translateY(0);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  .pause-btn.paused {
    background: #fef3c7;
    border-color: #f59e0b;
    color: #f59e0b;
  }

  .pause-btn.paused:hover {
    background: #fde68a;
    border-color: #d97706;
  }

  /* Hover highlight effects - All green themed */
  .row-highlight {
    background: rgba(34, 197, 94, 0.08) !important;
  }

  .col-highlight {
    background: rgba(34, 197, 94, 0.1) !important;
  }

  .box-highlight {
    background: rgba(34, 197, 94, 0.06) !important;
  }

  .cell-hover {
    background: rgba(34, 197, 94, 0.2) !important;
    box-shadow: inset 0 0 0 2px rgba(34, 197, 94, 0.4) !important;
  }

  /* Combine highlights for intersections */
  .row-highlight.col-highlight {
    background: rgba(34, 197, 94, 0.15) !important;
  }

  .row-highlight.box-highlight {
    background: rgba(34, 197, 94, 0.12) !important;
  }

  .col-highlight.box-highlight {
    background: rgba(34, 197, 94, 0.14) !important;
  }

  .row-highlight.col-highlight.box-highlight {
    background: rgba(34, 197, 94, 0.18) !important;
  }
  
  button { 
    flex: 1;
    min-width: 120px;
    padding: 12px;
    font-size: 16px;
    border: none;
    border-radius: 8px;
    background: var(--button-bg);
    color: white;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  button:hover {
    background: var(--button-hover);
  }
  
  table { 
    border-collapse: collapse; 
    margin: 0 auto;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  
  td {
    border: 1px solid #ddd;
    width: var(--cell-size); 
    height: var(--cell-size);
    text-align: center;
    position: relative;
    padding: 0;
  }
  
  input {
    width: 100%;
    height: 100%;
    text-align: center;
    font-size: calc(var(--cell-size) * 0.5);
    border: none;
    padding: 0;
    background: transparent;
    appearance: none;
    -webkit-appearance: none;
    position: relative;
    z-index: 10;
    caret-color: transparent;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    /* Additional mobile keyboard prevention */
    -webkit-touch-callout: none;
    -webkit-user-modify: read-only;
  }

  /* Prevent focus on mobile devices */
  input:focus {
    outline: none !important;
    -webkit-tap-highlight-color: transparent;
  }

  /* Additional mobile-specific styles */
  @media (max-width: 768px) {
    input {
      pointer-events: none;
    }
    
    td {
      pointer-events: auto;
      cursor: pointer;
    }
    
    /* Make sure mobile touch targets are large enough */
    td {
      touch-action: manipulation;
    }
  }
  
  /* Normal focus styles for desktop */
  @media (min-width: 769px) {
    input:focus {
      outline: 2px solid var(--button-bg);
      outline-offset: -2px;
    }
  }
  
  .fixed { 
    background: var(--fixed-bg); 
    font-weight: 600;
  }
  
  /* Style for revealed answer numbers */
  .revealed-answer {
    color: #2563eb;  /* 蓝色答案 */
    font-weight: 500;
    font-style: italic;
    background: #eff6ff;  /* 淡蓝色背景 */
  }
  
  /* Style for incorrect numbers */
  .incorrect {
    color: #dc2626;  /* 红色错误数字 */
    background: #fef2f2;  /* 淡红色背景 */
    position: relative;
  }
  
  /* Style for hint numbers */
  .hint-cell {
    color: #d97706 !important;  /* 橙色提示数字 */
    background: #fef3c7 !important;  /* 淡黄色背景 */
    font-weight: 600;
    border: 2px solid #f59e0b !important;
  }
  
  .incorrect::after {
    content: '×';
    position: absolute;
    top: -8px;
    right: 0;
    font-size: 12px;
    color: #dc2626;
    font-weight: bold;
  }
  
  /* Selected cell highlighting */
  .selected {
    background: #e0f2fe !important;
    outline: 3px solid var(--button-bg) !important;
    outline-offset: -3px;
  }
  
  /* Number panel styles - now single row */
  .number-panel {
    background: white;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    padding: 12px;
    border: 2px solid #e5e7eb;
  }
  
  .number-buttons {
    display: grid;
    grid-template-columns: repeat(9, 1fr);
    gap: 6px;
    max-width: 100%;
  }
  
  .number-btn {
    height: 48px;
    min-width: 48px;
    border: 2px solid #e5e7eb;
    border-radius: 8px;
    background: #f9fafb;
    color: #374151;
    font-size: 18px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    padding: 0;
  }
  
  .number-btn:hover {
    background: #e5e7eb;
    border-color: var(--button-bg);
    transform: translateY(-1px);
  }
  
  .number-btn:active {
    transform: translateY(0);
  }
  
  /* Clear button now positioned with Notes button */
  .clear-btn {
    padding: 12px 20px;
    border: 2px solid #fca5a5;
    border-radius: 12px;
    background: #fee2e2;
    color: #dc2626;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 100px;
    justify-content: center;
  }
  
  .clear-btn:hover {
    background: #fecaca;
    border-color: #f87171;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(220, 38, 38, 0.2);
  }
  
  .clear-icon {
    font-size: 18px;
  }
  
  .clear-text {
    font-size: 14px;
  }

  /* Disabled number button styles */
  .number-btn:disabled {
    background: #f3f4f6 !important;
    color: #9ca3af !important;
    border-color: #e5e7eb !important;
    cursor: not-allowed !important;
    opacity: 0.6;
    transform: none !important;
    box-shadow: none !important;
    position: relative;
  }

  .number-btn:disabled:hover {
    background: #f3f4f6 !important;
    color: #9ca3af !important;
    border-color: #e5e7eb !important;
    transform: none !important;
    box-shadow: none !important;
  }

  .number-btn:disabled::after {
    content: '✓';
    position: absolute;
    top: 2px;
    right: 2px;
    font-size: 10px;
    color: #22c55e;
    font-weight: bold;
  }

  /* Progress indicator for buttons */
  .number-btn {
    position: relative;
  }

  .number-btn:not(:disabled)::before {
    content: attr(data-count);
    position: absolute;
    bottom: 1px;
    right: 2px;
    font-size: 8px;
    color: #6b7280;
    background: rgba(255, 255, 255, 0.8);
    border-radius: 2px;
    padding: 0 2px;
    line-height: 1;
  }
  
  /* Old difficulty selector styles - removed in favor of compact dropdown */
  
  /* Input controls container */
  .input-controls {
    margin: 16px auto;
    max-width: 600px;
    width: 100%;
  }

  /* Control buttons row */
  .control-buttons {
    display: flex;
    justify-content: center;
    gap: 16px;
    margin-bottom: 12px;
  }
  
  .notes-toggle-btn {
    padding: 12px 20px;
    border: 2px solid #e5e7eb;
    border-radius: 12px;
    background: #f9fafb;
    color: #374151;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    font-size: 14px;
    font-weight: 500;
    min-width: 120px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  
  .notes-toggle-btn:hover {
    background: #f3f4f6;
    border-color: #9ca3af;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  }
  
  .notes-toggle-btn.active {
    background: var(--button-bg);
    border-color: var(--button-bg);
    color: white;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    transform: translateY(-1px);
  }
  
  .notes-toggle-btn.active:hover {
    background: var(--button-hover);
    border-color: var(--button-hover);
    box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
  }
  
  .mode-icon {
    font-size: 16px;
    transition: transform 0.2s;
  }
  
  .notes-toggle-btn.active .mode-icon {
    transform: scale(1.1);
  }
  
  .mode-name {
    font-weight: 500;
  }
  
  /* Old score board styles - merged into game-info */
  
  /* Notes grid styles */
  .notes-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    width: 100%;
    height: 100%;
    gap: 1px;
    padding: 2px;
    box-sizing: border-box;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 10;
  }
  
  /* In notes mode, notes grid displays below transparent input and doesn't receive clicks */
  body.notes-mode-active .cell-notes .notes-grid {
    z-index: 10; /* Below transparent input (z-index: 25) */
    pointer-events: none !important; /* Completely disable all mouse events */
  }
  
  .notes-cell {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 500;
    color: #666;
    background: transparent;
    min-height: 0;
    line-height: 1;
  }
  
  .notes-cell.filled {
    color: #2563eb;
    font-weight: 600;
  }
  
  /* Make regular input transparent but clickable when notes mode is active AND cell has notes */
  body.notes-mode-active .cell-notes .regular-input {
    opacity: 0;
    background: transparent !important;
    color: transparent !important;
    border: none !important;
    pointer-events: auto !important;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 25 !important; /* Highest z-index to ensure clickability */
    box-sizing: border-box;
  }
  
  /* Special focus ring in notes mode */
  body.notes-mode-active .regular-input:focus {
    outline: 2px solid #fbbf24;
    outline-offset: -2px;
  }
  
  /* Cell selection indicator for notes mode */
  .cell-selected-notes {
    box-shadow: inset 0 0 0 3px #fbbf24 !important;
    background: rgba(251, 191, 36, 0.1) !important;
  }
  
  /* Show notes grid when cell has notes */
  .cell-notes .notes-grid {
    display: grid;
  }
  
  .cell-regular .notes-grid {
    display: none;
  }
  
  /* In normal mode, show notes grid with reduced opacity */
  body:not(.notes-mode-active) .cell-notes .notes-grid {
    opacity: 0.3;
    pointer-events: none;
  }
  
  /* In notes mode, show notes grid with full opacity and allow interaction */
  body.notes-mode-active .cell-notes .notes-grid {
    opacity: 1;
    pointer-events: auto;
  }
  
  .thick-right { 
    border-right: 3px solid var(--border-color); 
  }
  
  .thick-bottom { 
    border-bottom: 3px solid var(--border-color); 
  }
  
  #message {
    margin: 16px 0;
    min-height: 24px;
    font-size: 16px;
  }
  
  @media (max-width: 480px) {
    body {
      padding: 8px;
    }
    
    .controls {
      padding: 0 8px;
    }
    
    button {
      padding: 10px;
      min-width: 100px;
      font-size: 14px;
    }
    
    input {
      font-size: calc(var(--cell-size) * 0.6);
    }
    
    .number-panel {
      margin: 16px auto;
      padding: 12px;
    }
    
    .number-buttons {
      grid-template-columns: repeat(5, 1fr);
      gap: 6px;
    }
    
    .number-btn {
      width: 45px;
      height: 45px;
      font-size: 16px;
    }
    
    .panel-title {
      font-size: 14px;
    }
    
    .controls-container {
      max-width: 100%;
    }
    
    .game-info {
      flex-direction: column;
      gap: 12px;
      padding: 12px;
    }
    
    .difficulty-dropdown {
      justify-content: center;
    }
    
    .difficulty-dropdown select {
      font-size: 13px;
      padding: 5px 10px;
    }
    
    .timer-display {
      justify-content: center;
    }
    
    .timer-section {
      font-size: 14px;
    }
    
    .timer-value {
      font-size: 16px;
    }
    
    .pause-btn {
      height: 32px;
      min-width: 32px;
      font-size: 14px;
    }
    
    .score-display {
      justify-content: center;
      font-size: 14px;
    }
    
    .score-value {
      font-size: 16px;
    }
    
    .input-controls {
      margin: 12px auto;
    }
    
    .control-buttons {
      flex-direction: column;
      gap: 8px;
      margin-bottom: 8px;
    }
    
    .notes-toggle-btn, .clear-btn {
      padding: 10px 16px;
      font-size: 13px;
      gap: 6px;
      min-width: 100px;
    }
    
    .mode-icon, .clear-icon {
      font-size: 14px;
    }
    
    .notes-cell {
      font-size: 8px;
    }
    
    .number-panel {
      padding: 8px;
    }
    
    .number-buttons {
      gap: 4px;
    }
    
    .number-btn {
      height: 40px;
      min-width: 40px;
      font-size: 16px;
    }
  }
  
  @media (min-width: 768px) {
    :root {
      --cell-size: 44px;
    }
  }
</style>
</head>
<body>
<h1>9×9 Sudoku Game</h1>
<div class="controls-container">
  <!-- Top row: Game controls -->
  <div class="controls">
    <button onclick="generateSudoku()">New Game</button>
    <button onclick="getHint()">💡 Hint</button>
    <button onclick="checkSudoku()">Check Answer</button>
    <button onclick="revealAnswer()">Peek Answer</button>
  </div>
  
  <!-- Bottom row: Difficulty, Timer, Score -->
  <div class="game-info">
    <div class="difficulty-dropdown">
      <label for="difficulty-select">Difficulty:</label>
      <select id="difficulty-select" onchange="setDifficulty(this.value)">
        <option value="easy" selected>Beginner (50 clues)</option>
        <option value="medium">Casual (40 clues)</option>
        <option value="hard">Challenge (32 clues)</option>
      </select>
    </div>
    
    <div class="timer-display">
      <div class="timer-section">
        <span class="timer-label">Time:</span>
        <span class="timer-value" id="game-timer">00:00</span>
      </div>
      <button class="pause-btn" onclick="toggleTimer()" id="pause-button">
        <span class="pause-icon" id="pause-icon">⏸️</span>
      </button>
    </div>
    
    <div class="score-display">
      <span class="score-label">Score:</span>
      <span class="score-value" id="current-score">1500</span>
      <span class="multiplier-text">×<span id="difficulty-multiplier">1.0</span></span>
    </div>
  </div>
</div>

<table id="sudoku"></table>
<p id="message"></p>

<div class="input-controls">
  <!-- Control buttons row -->
  <div class="control-buttons">
    <button class="notes-toggle-btn" onclick="toggleNotesMode()" id="notes-toggle">
      <span class="mode-icon">📝</span>
      <span class="mode-name">Notes</span>
    </button>
    <button class="clear-btn" onclick="fillNumber(0)">
      <span class="clear-icon">🧽</span>
      <span class="clear-text">Clear</span>
    </button>
  </div>
  
  <!-- Number selection row -->
  <div class="number-panel">
    <div class="number-buttons">
      <button class="number-btn" onclick="fillNumber(1)">1</button>
      <button class="number-btn" onclick="fillNumber(2)">2</button>
      <button class="number-btn" onclick="fillNumber(3)">3</button>
      <button class="number-btn" onclick="fillNumber(4)">4</button>
      <button class="number-btn" onclick="fillNumber(5)">5</button>
      <button class="number-btn" onclick="fillNumber(6)">6</button>
      <button class="number-btn" onclick="fillNumber(7)">7</button>
      <button class="number-btn" onclick="fillNumber(8)">8</button>
      <button class="number-btn" onclick="fillNumber(9)">9</button>
    </div>
  </div>
</div>

<script>
function createEmptyBoard() {
  return Array.from({ length: 9 }, () => Array(9).fill(0));
}

function isSafe(board, row, col, num) {
  for (let i = 0; i < 9; i++) {
    if (board[row][i] === num || board[i][col] === num) return false;
  }
  let startRow = Math.floor(row / 3) * 3;
  let startCol = Math.floor(col / 3) * 3;
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      if (board[startRow + r][startCol + c] === num) return false;
    }
  }
  return true;
}

function solveBoard(board) {
  for (let row = 0; row < 9; row++) {
    for (let col = 0; col < 9; col++) {
      if (board[row][col] === 0) {
        let nums = [1,2,3,4,5,6,7,8,9];
        nums.sort(() => Math.random() - 0.5);
        for (let num of nums) {
          if (isSafe(board, row, col, num)) {
            board[row][col] = num;
            if (solveBoard(board)) return true;
            board[row][col] = 0;
          }
        }
        return false;
      }
    }
  }
  return true;
}

function generateFullSudoku() {
  let board = createEmptyBoard();
  solveBoard(board);
  return board;
}

function generatePuzzle(fullBoard, clues = 35) {
  let puzzle = fullBoard.map(row => row.slice());
  let removeCount = 81 - clues;
  while (removeCount > 0) {
    let r = Math.floor(Math.random() * 9);
    let c = Math.floor(Math.random() * 9);
    if (puzzle[r][c] !== 0) {
      puzzle[r][c] = 0;
      removeCount--;
    }
  }
  return puzzle;
}

let solutionBoard = null;
let puzzleBoard = null;
let selectedCell = null; // Track selected cell {row, col}
let currentDifficulty = 'easy'; // Current difficulty level
let isNotesMode = false; // Notes mode state
let notesBoard = null; // Store notes for each cell
let currentScore = 1500; // Starting score (increased for more margin)

// Timer variables
let gameStartTime = null;
let gameElapsedTime = 0; // Total elapsed time in seconds
let timerInterval = null;
let isTimerPaused = false;

// Difficulty settings with scoring multipliers
const difficultySettings = {
  easy: { clues: 50, name: 'Beginner', multiplier: 1.0 },
  medium: { clues: 40, name: 'Casual', multiplier: 1.2 },
  hard: { clues: 32, name: 'Challenge', multiplier: 1.5 }
};

// Scoring system
const scoreSettings = {
  correct: 15,    // Base points for correct answer (increased)
  incorrect: -10, // Points deducted for wrong answer (reduced penalty)
  completion: 800 // Bonus for completing puzzle (increased)
};

// Initialize notes board
function initNotesBoard() {
  notesBoard = Array.from({ length: 9 }, () => 
    Array.from({ length: 9 }, () => new Set())
  );
}

// Score management functions
function updateScore(points) {
  const multiplier = difficultySettings[currentDifficulty].multiplier;
  const adjustedPoints = Math.round(points * multiplier);
  currentScore = Math.max(0, currentScore + adjustedPoints); // Prevent negative scores
  
  // Update display
  document.getElementById('current-score').textContent = currentScore;
  
  // Show score change animation
  showScoreChange(adjustedPoints);
}

function showScoreChange(points) {
  const scoreElement = document.getElementById('current-score');
  const changeElement = document.createElement('div');
  
  changeElement.textContent = points > 0 ? `+${points}` : `${points}`;
  changeElement.style.cssText = `
    position: absolute;
    font-size: 14px;
    font-weight: 600;
    color: ${points > 0 ? '#10b981' : '#ef4444'};
    pointer-events: none;
    animation: scoreFloat 1.5s ease-out forwards;
    z-index: 100;
  `;
  
  // Add floating animation
  const style = document.createElement('style');
  style.textContent = `
    @keyframes scoreFloat {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-30px); opacity: 0; }
    }
  `;
  document.head.appendChild(style);
  
  scoreElement.parentElement.style.position = 'relative';
  scoreElement.parentElement.appendChild(changeElement);
  
  setTimeout(() => {
    changeElement.remove();
  }, 1500);
}

function resetScore() {
  currentScore = 1500;
  document.getElementById('current-score').textContent = currentScore;
}

function updateDifficultyDisplay() {
  const multiplier = difficultySettings[currentDifficulty].multiplier;
  document.getElementById('difficulty-multiplier').textContent = `${multiplier}x`;
}

// Timer functions
function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

function updateTimerDisplay() {
  document.getElementById('game-timer').textContent = formatTime(gameElapsedTime);
}

function startTimer() {
  if (timerInterval) clearInterval(timerInterval);
  
  gameStartTime = Date.now() - (gameElapsedTime * 1000);
  isTimerPaused = false;
  
  timerInterval = setInterval(() => {
    if (!isTimerPaused) {
      gameElapsedTime = Math.floor((Date.now() - gameStartTime) / 1000);
      updateTimerDisplay();
    }
  }, 1000);
  
  updatePauseButton();
}

function pauseTimer() {
  isTimerPaused = true;
  updatePauseButton();
}

function resumeTimer() {
  isTimerPaused = false;
  gameStartTime = Date.now() - (gameElapsedTime * 1000);
  updatePauseButton();
}

function resetTimer() {
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = null;
  gameElapsedTime = 0;
  gameStartTime = null;
  isTimerPaused = false;
  updateTimerDisplay();
  updatePauseButton();
}

function toggleTimer() {
  if (isTimerPaused) {
    resumeTimer();
  } else {
    pauseTimer();
  }
}

function updatePauseButton() {
  const pauseBtn = document.getElementById('pause-button');
  const pauseIcon = document.getElementById('pause-icon');
  
  if (isTimerPaused) {
    pauseBtn.classList.add('paused');
    pauseIcon.textContent = '▶️';
    pauseBtn.title = 'Resume timer';
  } else {
    pauseBtn.classList.remove('paused');
    pauseIcon.textContent = '⏸️';
    pauseBtn.title = 'Pause timer';
  }
}

// Cell hover highlight functions
function highlightRelatedCells(row, col) {
  const table = document.getElementById('sudoku');
  clearAllHighlights();
  
  // Calculate 3x3 box boundaries
  const boxStartRow = Math.floor(row / 3) * 3;
  const boxStartCol = Math.floor(col / 3) * 3;
  
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      const cell = table.rows[r].cells[c];
      
      // Current cell gets special hover style
      if (r === row && c === col) {
        cell.classList.add('cell-hover');
        continue;
      }
      
      // Same row
      if (r === row) {
        cell.classList.add('row-highlight');
      }
      
      // Same column
      if (c === col) {
        cell.classList.add('col-highlight');
      }
      
      // Same 3x3 box
      if (r >= boxStartRow && r < boxStartRow + 3 && 
          c >= boxStartCol && c < boxStartCol + 3) {
        cell.classList.add('box-highlight');
      }
    }
  }
}

function clearAllHighlights() {
  const table = document.getElementById('sudoku');
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      const cell = table.rows[r].cells[c];
      cell.classList.remove('row-highlight', 'col-highlight', 'box-highlight', 'cell-hover');
    }
  }
}

function addCellHoverEvents(cell, row, col) {
  cell.addEventListener('mouseenter', () => {
    highlightRelatedCells(row, col);
  });
  
  cell.addEventListener('mouseleave', () => {
    clearAllHighlights();
  });
}

// Check if a number is complete (appears 9 times) and update button states
function updateNumberButtonStates() {
  const table = document.getElementById('sudoku');
  const numberCounts = {};
  
  // Initialize counts
  for (let num = 1; num <= 9; num++) {
    numberCounts[num] = 0;
  }
  
  // Count all numbers on the board
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      const input = table.rows[r].cells[c].querySelector('input');
      if (input && input.value) {
        const num = parseInt(input.value);
        if (num >= 1 && num <= 9) {
          numberCounts[num]++;
        }
      }
    }
  }
  
  // Update button states
  for (let num = 1; num <= 9; num++) {
    const button = document.querySelector(`button[onclick="fillNumber(${num})"]`);
    if (button) {
      const count = numberCounts[num];
      
      // Set data attribute for CSS counter display
      button.setAttribute('data-count', `${count}/9`);
      
      if (count >= 9) {
        button.disabled = true;
        button.title = `Number ${num} is complete (9/9)`;
      } else {
        button.disabled = false;
        button.title = `Fill number ${num} (${count}/9)`;
      }
    }
  }
}

function getNumberCount(num) {
  const table = document.getElementById('sudoku');
  let count = 0;
  
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      const input = table.rows[r].cells[c].querySelector('input');
      if (input && input.value && parseInt(input.value) === num) {
        count++;
      }
    }
  }
  
  return count;
}

function renderBoard(puzzle) {
  const table = document.getElementById('sudoku');
  table.innerHTML = '';
  selectedCell = null; // Reset selection
  
  for (let r = 0; r < 9; r++) {
    let tr = document.createElement('tr');
    for (let c = 0; c < 9; c++) {
      let td = document.createElement('td');
      if ((c+1) % 3 === 0 && c < 8) td.classList.add('thick-right');
      if ((r+1) % 3 === 0 && r < 8) td.classList.add('thick-bottom');

      if (puzzle[r][c] !== 0) {
        // Fixed cell - only show the number (no click event needed for fixed cells)
        td.innerHTML = `<input type="text" value="${puzzle[r][c]}" readonly class="fixed regular-input" 
                               inputmode="none" autocomplete="off" tabindex="-1" 
                               onfocus="this.blur();">`;
      } else {
        // Empty cell - support both regular input and notes
        const hasNotes = notesBoard && notesBoard[r][c] && notesBoard[r][c].size > 0;
        const cellClass = hasNotes ? 'cell-notes' : 'cell-regular';
        
        td.classList.add(cellClass);
        // Add click event to td for mobile compatibility
        td.onclick = function() { selectCell(r, c); };
        td.innerHTML = `
          <input type="text" onclick="selectCell(${r}, ${c})" class="regular-input" maxlength="1" 
                 readonly="readonly"
                 inputmode="none"
                 autocomplete="off"
                 tabindex="-1"
                 onkeydown="return false;" 
                 onkeypress="return false;" 
                 onkeyup="return false;"
                 oninput="handleInput(event, ${r}, ${c})"
                 onpaste="return false;"
                 ondrop="return false;"
                 onfocus="this.blur();">
          <div class="notes-grid">
            ${renderNotesGrid(r, c)}
          </div>
        `;
      }
      
      // Add hover events for cell highlighting
      addCellHoverEvents(td, r, c);
      
      tr.appendChild(td);
    }
    table.appendChild(tr);
  }
  
  // Update number button states after rendering
  updateNumberButtonStates();
}

// Render 3x3 notes grid for a cell (display only, no click events)
function renderNotesGrid(row, col) {
  let html = '';
  for (let i = 1; i <= 9; i++) {
    const hasNote = notesBoard && notesBoard[row][col] && notesBoard[row][col].has(i);
    const cellClass = hasNote ? 'notes-cell filled' : 'notes-cell';
    const content = hasNote ? i : '';
    // Removed onclick event - all input must go through number panel
    html += `<div class="${cellClass}">${content}</div>`;
  }
  return html;
}

// Toggle notes mode
function toggleNotesMode() {
  isNotesMode = !isNotesMode;
  
  // Update body class to control CSS display rules
  if (isNotesMode) {
    document.body.classList.add('notes-mode-active');
  } else {
    document.body.classList.remove('notes-mode-active');
  }
  
  // Update button styles
  const toggleBtn = document.getElementById('notes-toggle');
  if (isNotesMode) {
    toggleBtn.classList.add('active');
  } else {
    toggleBtn.classList.remove('active');
  }
  
  // Update selection display to match new mode
  if (selectedCell) {
    const table = document.getElementById('sudoku');
    const cell = table.rows[selectedCell.row].cells[selectedCell.col].querySelector('input');
    const td = table.rows[selectedCell.row].cells[selectedCell.col];
    
    // Clear all selection styles
    cell.classList.remove('selected');
    td.classList.remove('cell-selected-notes');
    
    // Apply appropriate selection style for current mode
    if (!cell.classList.contains('fixed')) {
      if (isNotesMode) {
        td.classList.add('cell-selected-notes');
      } else {
        cell.classList.add('selected');
      }
    }
  }
  
  // Show feedback message
  const modeText = isNotesMode ? 'Notes Mode' : 'Normal Mode';
  const icon = isNotesMode ? '📝' : '🔢';
  document.getElementById('message').textContent = `${icon} Switched to ${modeText}`;
  setTimeout(() => {
    document.getElementById('message').textContent = '';
  }, 2000);
}

// toggleNote function removed - all notes operations now go through fillNumber function and number panel

// Render a single cell (helper function)
function renderSingleCell(row, col) {
  const table = document.getElementById('sudoku');
  const td = table.rows[row].cells[col];
  const puzzle = puzzleBoard;
  
  // Preserve border classes and selection state
  const thickRight = td.classList.contains('thick-right');
  const thickBottom = td.classList.contains('thick-bottom');
  const isSelected = selectedCell && selectedCell.row === row && selectedCell.col === col;
  
  if (puzzle[row][col] !== 0) {
    // Fixed cell
    td.className = '';
    if (thickRight) td.classList.add('thick-right');
    if (thickBottom) td.classList.add('thick-bottom');
    td.innerHTML = `<input type="text" value="${puzzle[row][col]}" readonly class="fixed regular-input" 
                           inputmode="none" autocomplete="off" tabindex="-1" 
                           onfocus="this.blur();">`;
  } else {
    // Empty cell - support both regular input and notes
    const hasNotes = notesBoard && notesBoard[row][col] && notesBoard[row][col].size > 0;
    const cellClass = hasNotes ? 'cell-notes' : 'cell-regular';
    
    td.className = '';
    if (thickRight) td.classList.add('thick-right');
    if (thickBottom) td.classList.add('thick-bottom');
    td.classList.add(cellClass);
    
    // Restore selection state after re-rendering
    if (isSelected) {
      if (isNotesMode) {
        td.classList.add('cell-selected-notes');
      }
      // Don't add 'selected' to input in notes mode as it might be transparent
    }
    
    // Add click event to td for mobile compatibility
    td.onclick = function() { selectCell(row, col); };
    td.innerHTML = `
      <input type="text" onclick="selectCell(${row}, ${col})" class="regular-input ${isSelected && !isNotesMode ? 'selected' : ''}" maxlength="1" 
             readonly="readonly"
             inputmode="none"
             autocomplete="off"
             tabindex="-1"
             onkeydown="return false;" 
             onkeypress="return false;" 
             onkeyup="return false;"
             oninput="handleInput(event, ${row}, ${col})"
             onpaste="return false;"
             ondrop="return false;"
             onfocus="this.blur();">
      <div class="notes-grid">
        ${renderNotesGrid(row, col)}
      </div>
    `;
  }
  
  // Re-add hover events after re-rendering
  addCellHoverEvents(td, row, col);
}

// Set difficulty level
function setDifficulty(level) {
  currentDifficulty = level;
  
  // Update select dropdown to reflect the current selection
  document.getElementById('difficulty-select').value = level;
  
  // Update difficulty multiplier display
  updateDifficultyDisplay();
  
  // Generate new game with the selected difficulty
  generateSudoku();
  
  // Show feedback message (will override the generation message briefly)
  const settings = difficultySettings[level];
  setTimeout(() => {
    document.getElementById('message').textContent = `🎯 New ${settings.name} game started! (${settings.clues} clues, ${settings.multiplier}x score)`;
    setTimeout(() => {
      document.getElementById('message').textContent = '';
    }, 2500);
  }, 100);
}

// Strict input handling - only allow through number panel
function handleInput(event, row, col) {
  const input = event.target;
  
  // Completely prevent any direct input in both modes
  // All input should go through the number panel
  event.preventDefault();
  input.value = ''; // Clear any value that might have been entered
  return false;
}

// Handle cell selection
function selectCell(row, col) {
  // Debug log for mobile testing
  console.log('selectCell called:', row, col);
  
  // Clear previous selection
  document.querySelectorAll('.selected').forEach(cell => {
    cell.classList.remove('selected');
  });
  document.querySelectorAll('.cell-selected-notes').forEach(cell => {
    cell.classList.remove('cell-selected-notes');
  });
  
  // Select new cell
  const table = document.getElementById('sudoku');
  const cell = table.rows[row].cells[col].querySelector('input');
  const td = table.rows[row].cells[col];
  
  // Only select if it's not a fixed cell
  if (!cell.classList.contains('fixed')) {
    if (isNotesMode) {
      // In notes mode, highlight the entire cell (td element)
      td.classList.add('cell-selected-notes');
    } else {
      // In normal mode, highlight the input element
      cell.classList.add('selected');
    }
    
    selectedCell = { row, col };
    console.log('Cell selected:', selectedCell);
  } else {
    console.log('Fixed cell, not selectable');
  }
}

// Fill number in selected cell
function fillNumber(num) {
  if (!selectedCell) {
    const modeText = isNotesMode ? 'notes' : 'number';
    document.getElementById('message').textContent = `⚠️ Please select a cell first, then use number panel to input ${modeText}!`;
    setTimeout(() => {
      document.getElementById('message').textContent = '';
    }, 3000);
    return;
  }
  
  // Check if number is complete (except for clearing with 0)
  if (num !== 0 && getNumberCount(num) >= 9) {
    document.getElementById('message').textContent = `⚠️ Number ${num} is already complete (9/9)!`;
    setTimeout(() => {
      document.getElementById('message').textContent = '';
    }, 2000);
    return;
  }
  
  const table = document.getElementById('sudoku');
  const cell = table.rows[selectedCell.row].cells[selectedCell.col].querySelector('input');
  
  // Don't allow editing fixed cells
  if (cell.classList.contains('fixed')) {
    return;
  }
  
  if (isNotesMode) {
    // Notes mode: toggle note
    if (num === 0) {
      // Clear all notes
      if (notesBoard[selectedCell.row][selectedCell.col]) {
        notesBoard[selectedCell.row][selectedCell.col].clear();
      }
    } else {
      // Toggle specific note
      if (!notesBoard[selectedCell.row][selectedCell.col]) {
        notesBoard[selectedCell.row][selectedCell.col] = new Set();
      }
      
      if (notesBoard[selectedCell.row][selectedCell.col].has(num)) {
        notesBoard[selectedCell.row][selectedCell.col].delete(num);
      } else {
        notesBoard[selectedCell.row][selectedCell.col].add(num);
      }
    }
    
    // Clear regular number when adding notes
    cell.value = '';
    cell.classList.remove('incorrect');
    
    // Re-render the cell to show updated notes
    renderSingleCell(selectedCell.row, selectedCell.col);
  } else {
    // Normal mode: fill regular number
    if (num === 0) {
      // Remove readonly temporarily to clear value, then restore it
      cell.removeAttribute('readonly');
      cell.value = '';
      cell.setAttribute('readonly', 'readonly');
      cell.classList.remove('incorrect');
      // Update cell class when clearing
      const td = cell.parentElement;
      const hasNotes = notesBoard[selectedCell.row][selectedCell.col] && notesBoard[selectedCell.row][selectedCell.col].size > 0;
      if (hasNotes) {
        td.classList.remove('cell-regular');
        td.classList.add('cell-notes');
      } else {
        td.classList.remove('cell-notes');
        td.classList.add('cell-regular');
      }
    } else {
      // Remove readonly temporarily to set value, then restore it
      cell.removeAttribute('readonly');
      cell.value = num;
      cell.setAttribute('readonly', 'readonly');
      cell.classList.remove('incorrect');
      
      // Check if the answer is correct (auto-check in normal mode)
      const correctAnswer = solutionBoard[selectedCell.row][selectedCell.col];
      const isCorrect = parseInt(num) === correctAnswer;
      
      if (isCorrect) {
        // Correct answer - add points
        updateScore(scoreSettings.correct);
        cell.style.background = '#dcfce7'; // Light green
        setTimeout(() => {
          cell.style.background = '';
        }, 1000);
        
        // Check if puzzle is completed
        setTimeout(checkPuzzleCompletion, 100);
      } else {
        // Wrong answer - deduct points and mark as incorrect
        updateScore(scoreSettings.incorrect);
        cell.classList.add('incorrect');
        cell.style.background = '#fee2e2'; // Light red
        setTimeout(() => {
          cell.style.background = '';
        }, 1000);
      }
      
      // Always update cell class when filling regular number
      const td = cell.parentElement;
      
      // Clear notes when filling regular number
      if (notesBoard[selectedCell.row][selectedCell.col]) {
        notesBoard[selectedCell.row][selectedCell.col].clear();
      }
      
      // Always ensure cell is in regular mode when filling number
      td.classList.remove('cell-notes');
      td.classList.add('cell-regular');
    }
  }
  
  // Clear message
  document.getElementById('message').textContent = '';
  
  // Update number button states after any change
  updateNumberButtonStates();
}

// Check if puzzle is completed
function checkPuzzleCompletion() {
  const table = document.getElementById('sudoku');
  let correctCount = 0;
  let totalCells = 0;
  
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      const input = table.rows[r].cells[c].querySelector('input');
      if (!input.classList.contains('fixed')) {
        totalCells++;
        if (input.value && parseInt(input.value) === solutionBoard[r][c]) {
          correctCount++;
        }
      }
    }
  }
  
  if (correctCount === totalCells) {
    // Puzzle completed!
    pauseTimer(); // Stop the timer when puzzle is completed
    
    const completionBonus = Math.round(scoreSettings.completion * difficultySettings[currentDifficulty].multiplier);
    updateScore(scoreSettings.completion);
    
    setTimeout(() => {
      const difficulty = difficultySettings[currentDifficulty].name;
      const completionTime = formatTime(gameElapsedTime);
      document.getElementById('message').innerHTML = `
        🎉 <strong>Congratulations!</strong><br>
        ${difficulty} puzzle completed!<br>
        Time: <strong>${completionTime}</strong><br>
        Final Score: <strong>${currentScore}</strong><br>
        Completion Bonus: <strong>+${completionBonus}</strong>
      `;
      document.getElementById('message').style.cssText = `
        color: #10b981;
        font-size: 16px;
        font-weight: 600;
        text-align: center;
        padding: 16px;
        background: #dcfce7;
        border-radius: 8px;
        border: 2px solid #10b981;
        margin: 16px auto;
        max-width: 300px;
      `;
    }, 500);
  }
}

function generateSudoku() {
  const full = generateFullSudoku();
  const clues = difficultySettings[currentDifficulty].clues;
  const puzzle = generatePuzzle(full, clues);
  solutionBoard = full;
  puzzleBoard = puzzle;
  
  // Initialize notes board
  initNotesBoard();
  
  // Reset score
  resetScore();
  
  // Reset and start timer
  resetTimer();
  startTimer();
  
  renderBoard(puzzle);
  
  // Reset message styles
  const messageEl = document.getElementById('message');
  messageEl.style.cssText = '';
  
  // Show generation message
  const difficultyName = difficultySettings[currentDifficulty].name;
  messageEl.textContent = `🎮 New ${difficultyName} puzzle generated!`;
  setTimeout(() => {
    messageEl.textContent = '';
  }, 2000);
  
  // Reset selection state
  selectedCell = null;
  
  // Reset peek answer state
  isShowingAnswer = false;
  originalPuzzle = null;
  const peekButton = document.querySelector('button[onclick="revealAnswer()"]');
  peekButton.textContent = 'Peek Answer';
  peekButton.style.background = '';
  
  // Clear any incorrect marks and selections
  document.querySelectorAll('.incorrect, .selected, .cell-selected-notes').forEach(cell => {
    cell.classList.remove('incorrect', 'selected', 'cell-selected-notes');
  });
}

function checkSudoku() {
  let table = document.getElementById('sudoku');
  let hasError = false;
  let filledCount = 0;
  let totalCells = 81;
  
  // 先清除所有之前的错误标记
  document.querySelectorAll('.incorrect').forEach(cell => {
    cell.classList.remove('incorrect');
  });
  
  // 检查所有已填入的数字
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      let cell = table.rows[r].cells[c].querySelector('input');
      let val = cell.value.trim();
      
      // 跳过空格
      if (!val) continue;
      
      filledCount++;
      val = parseInt(val);
      
      // 检查数字是否正确
      if (val !== solutionBoard[r][c]) {
        cell.classList.add('incorrect');
        hasError = true;
      }
    }
  }
  
  // 更新消息
  const msgEl = document.getElementById('message');
  if (filledCount === 0) {
    msgEl.textContent = '❗ Please fill in some numbers first!';
  } else if (hasError) {
    msgEl.textContent = `❌ Found ${document.querySelectorAll('.incorrect').length} incorrect numbers`;
  } else if (filledCount < totalCells) {
    msgEl.textContent = `✅ All ${filledCount} numbers correct, ${totalCells - filledCount} to go!`;
  } else {
    msgEl.textContent = '🎉 Congratulations, well done!';
  }
}

// Store original puzzle state
let originalPuzzle = null;
let isShowingAnswer = false;

// Toggle between "Peek Answer" and "Continue Game"
function revealAnswer() {
  const table = document.getElementById('sudoku');
  const peekButton = document.querySelector('button[onclick="revealAnswer()"]');
  
  if (!isShowingAnswer) {
    // Save current game state
    originalPuzzle = Array(9).fill().map(() => Array(9).fill(0));
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        let cell = table.rows[r].cells[c].querySelector('input');
        originalPuzzle[r][c] = {
          value: cell.value,
          readOnly: cell.readOnly,
          isFixed: cell.classList.contains('fixed'),
          isSelected: cell.classList.contains('selected')
        };
      }
    }
    
    // Clear selection when showing answer
    selectedCell = null;
    
    // Show answer
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        let cell = table.rows[r].cells[c].querySelector('input');
        // 如果不是原始数字，使用特殊样式显示答案
        if (!cell.classList.contains('fixed')) {
          cell.value = solutionBoard[r][c];
          cell.classList.add('revealed-answer');
          cell.classList.remove('selected', 'incorrect');
        }
      }
    }
    document.getElementById('message').textContent = '🔍 Answer revealed!';
    peekButton.textContent = 'Continue';
    peekButton.style.background = 'var(--button-hover)';
  } else {
    // Restore original game state
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        let cell = table.rows[r].cells[c].querySelector('input');
        let original = originalPuzzle[r][c];
        cell.value = original.value;
        cell.classList.remove('revealed-answer');
        if (original.isSelected) {
          cell.classList.add('selected');
          selectedCell = { row: r, col: c };
        }
        if (!original.isFixed) {
          cell.classList.remove('fixed');
        }
      }
    }
    document.getElementById('message').textContent = '';
    peekButton.textContent = 'Peek Answer';
    peekButton.style.background = '';
  }
  
  isShowingAnswer = !isShowingAnswer;
}

// Get hint function - fills one empty cell with correct answer
function getHint() {
  const table = document.getElementById('sudoku');
  const emptyCells = [];
  
  // Find all empty cells
  for (let r = 0; r < 9; r++) {
    for (let c = 0; c < 9; c++) {
      const input = table.rows[r].cells[c].querySelector('input');
      if (!input.classList.contains('fixed') && !input.value) {
        emptyCells.push({ row: r, col: c, input: input });
      }
    }
  }
  
  if (emptyCells.length === 0) {
    document.getElementById('message').textContent = '💡 No empty cells to hint!';
    setTimeout(() => {
      document.getElementById('message').textContent = '';
    }, 2000);
    return;
  }
  
  // Pick a random empty cell
  const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
  const correctAnswer = solutionBoard[randomCell.row][randomCell.col];
  
  // Fill the cell with correct answer
  randomCell.input.removeAttribute('readonly');
  randomCell.input.value = correctAnswer;
  randomCell.input.setAttribute('readonly', 'readonly');
  randomCell.input.style.background = '#fef3c7'; // Light yellow for hint
  randomCell.input.style.color = '#d97706'; // Orange text
  randomCell.input.classList.add('hint-cell');
  
  // Deduct points for using hint
  const hintPenalty = -15; // Fixed penalty for using hint
  updateScore(hintPenalty);
  
  // Clear any notes for this cell
  if (notesBoard[randomCell.row][randomCell.col]) {
    notesBoard[randomCell.row][randomCell.col].clear();
    const td = randomCell.input.parentElement;
    td.classList.remove('cell-notes');
    td.classList.add('cell-regular');
  }
  
  // Show hint message
  document.getElementById('message').textContent = `💡 Hint used! ${hintPenalty} points`;
  setTimeout(() => {
    document.getElementById('message').textContent = '';
    randomCell.input.style.background = '';
  }, 2000);
  
  // Update number button states after hint
  updateNumberButtonStates();
  
  // Check if puzzle is completed
  setTimeout(checkPuzzleCompletion, 100);
}

// Mobile keyboard prevention
function preventMobileKeyboard() {
  // Additional protection for mobile devices
  const inputs = document.querySelectorAll('input');
  inputs.forEach(input => {
    // Prevent any chance of focus (only on input elements)
    input.addEventListener('focus', function(e) {
      this.blur();
      e.preventDefault();
    });
  });
  
  // Prevent zoom on double tap for iOS (but allow single taps)
  let lastTouchEnd = 0;
  document.addEventListener('touchend', function (event) {
    const now = (new Date()).getTime();
    if (now - lastTouchEnd <= 300) {
      event.preventDefault();
    }
    lastTouchEnd = now;
  }, false);
}

// Initialize the game
initNotesBoard();
updateDifficultyDisplay();
updateTimerDisplay();
updatePauseButton();
generateSudoku();

// Apply mobile protections after DOM is ready
if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
  preventMobileKeyboard();
}
</script>
</body>
</html>


