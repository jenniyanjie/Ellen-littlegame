<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ellen's Missing Letter</title>
<style>
  :root{
    --bg:#f6f7fb; --card:#fff; --ink:#1f2d3d; --muted:#708090;
    --accent:#5c7cfa; --ok:#22c55e; --bad:#ef4444;
  }
  html,body{margin:0;height:100%;font-family:system-ui,-apple-system,Segoe UI,Roboto,PingFang SC,Microsoft YaHei,Arial;}
  body{background:linear-gradient(180deg,#eef2ff, #f6f7fb);}
  .wrap{max-width:1440px;margin:28px auto;padding:28px;}
  .game{background:var(--card);box-shadow:0 12px 36px rgba(21,24,79,.08);border-radius:19px;padding:24px;}
  h1{margin:10px 0 14px;font-size:38px;color:var(--ink)}
  .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  select,button{border:1px solid #dce0f0;border-radius:12px;padding:14px 19px;background:#fff;color:var(--ink);font-size:19px;cursor:pointer}
  button.primary{background:var(--accent);color:#fff;border:none}
  button.good{background:var(--ok);color:#fff;border:none}
  button.bad{background:var(--bad);color:#fff;border:none}
  button.hint{background:#ffc107;color:#212529;border:none;font-weight:600}
  .status{margin-left:auto;color:var(--muted);font-size:13px}
  .card{margin:18px 0;padding:18px;border:1px dashed #e3e7ff;border-radius:12px;background:#fafbff}
  .word-display{display:flex;align-items:center;justify-content:center;gap:20px;margin:20px 0;padding:20px;background:#fff;border-radius:12px;box-shadow:0 4px 12px rgba(0,0,0,.08);border:2px solid #eef2ff}
  .word-speak-btn{padding:14px 24px;border:none;border-radius:10px;background:var(--accent);color:#fff;cursor:pointer;font-size:22px;display:flex;align-items:center;gap:10px;transition:all 0.2s}
  .word-speak-btn:hover{background:#4c68d9;transform:scale(1.05)}
  .word-speak-btn:active{transform:scale(0.98)}
  .word-translation{color:var(--muted);font-size:24px;font-weight:500;background:#f8faff;padding:14px 19px;border-radius:7px;border:1px solid #e3e7ff}
  .mask{display:flex;gap:10px;flex-wrap:nowrap;justify-content:center;margin:14px 0;overflow-x:auto;padding:5px}
  .slot{width:77px;height:96px;border-radius:14px;background:#fff;display:grid;place-items:center;
        box-shadow:0 7px 17px rgba(0,0,0,.06);font-size:43px;font-weight:700;letter-spacing:1px;flex-shrink:0}
  .slot.hole{outline:2px dashed #c7d2fe; background:#f8faff;color:#9aa3b2}
  
  /* Mobile responsive design */
  @media (max-width: 768px) {
    .puzzle-container {
      flex-direction: column !important;
      gap: 12px !important;
      margin: 12px 0 !important;
      align-items: center !important;
    }
    
    .mask {
      width: 100%;
      max-width: calc(100vw - 40px);
      justify-content: center;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      -ms-overflow-style: none;
      padding: 0 10px;
    }
    
    .mask::-webkit-scrollbar {
      display: none;
    }
    
    /* Ensure translation is centered when displayed */
    .word-translation {
      text-align: center;
      align-self: center;
    }
  }
  
  @media (max-width: 480px) {
    .slot {
      width: calc((100vw - 80px) / 8);
      min-width: 48px;
      max-width: 67px;
      height: 72px;
      font-size: 34px;
    }
    
    .word-translation {
      font-size: 22px;
      padding: 10px 14px;
    }
    
    .word-display {
      gap: 14px;
      margin: 14px 0;
      padding: 14px;
    }
    
    .word-speak-btn {
      padding: 12px 19px;
      font-size: 19px;
    }
  }
  .letters{display:grid;grid-template-columns:repeat(auto-fit,minmax(67px,1fr));gap:14px;margin-top:14px}
  .letters button{height:67px;font-weight:700;font-size:29px}
  .letters button.used{background:#e5e7eb;color:#9ca3af;cursor:not-allowed;opacity:0.6}
  .letters button.used:hover{background:#e5e7eb;transform:none}
  
  /* Mobile optimization for letter bank */
  @media (max-width: 480px) {
    .letters {
      grid-template-columns: repeat(auto-fit, minmax(58px, 1fr));
      gap: 10px;
      margin-top: 14px;
    }
    
    .letters button {
      height: 58px;
      font-size: 26px;
      font-weight: 600;
    }
  }
  .meta{display:flex;gap:14px;justify-content:center;color:#6b7280;font-size:19px}
  .feedback{min-height:38px;text-align:center;font-size:24px;margin-top:14px}
  .pill{display:inline-block;background:#eef2ff;color:#475569;padding:7px 17px;border-radius:999px;font-size:17px}
  .tiny{font-size:17px;color:#94a3b8}
  .bigword{font-size:50px;letter-spacing:5px;text-align:center}
</style>
</head>
<body>
  <div class="wrap">
    <div class="game">
      <h1>Ellen's filling letter game</h1>
      <div class="controls">
        <!-- Audio playback button (hidden - moved to word display) -->
        <button id="speak" style="display:none">ðŸ”Š Play Audio</button>
        <!-- Show answer button (appears after wrong answer) -->
        <button id="showAnswer" class="hint" style="display:none">ðŸ’¡ Show Answer</button>
        <div class="status" id="status">Score 0 | Streak 0 | Progress: 0/0</div>
      </div>

      <div class="card">
        <div class="meta">
          <span class="pill" id="cat">â€”</span>
          <span class="tiny">Tip: Click letter cards below to fill blanks; click filled letters to remove.</span>
        </div>
        
        <!-- Game controls with speaker -->
        <div id="gameControls" class="word-display">
          <button id="wordSpeakBtn" class="word-speak-btn">ðŸ”Š Play</button>
          <button id="next" class="primary">New</button>
          <button id="replay">Retry</button>
        </div>
        
        <!-- Word puzzle and translation -->
        <div class="puzzle-container" style="display:flex;align-items:center;justify-content:center;gap:20px;margin:20px 0">
          <div id="mask" class="mask" style="margin:0"></div>
          <div id="wordTranslation" class="word-translation" style="display:none"></div>
        </div>
        <div id="letterBank" class="letters"></div>
        <div id="feedback" class="feedback"></div>
      </div>

      <div class="meta tiny" style="display:none;">
        Source: Dolch Sight Words.
        <div id="voiceInfo" style="display:none;"></div>
      </div>
    </div>
  </div>

<script>
// ---- Dolch Words Database with Chinese Translations ----
const WORDS_WITH_TRANSLATIONS = {
  // New words from user's curriculum
  "were":"æ˜¯", "yes":"æ˜¯çš„", "may":"å¯èƒ½", "or":"æˆ–è€…", "an":"ä¸€ä¸ª", "tail":"å°¾å·´", "paws":"çˆªå­", "fur":"æ¯›çš®", "beak":"é¸Ÿå˜´", "feathers":"ç¾½æ¯›",
  "around":"å‘¨å›´", "animals":"åŠ¨ç‰©", "eyes":"çœ¼ç›", "wish":"å¸Œæœ›", "then":"ç„¶åŽ", "growl":"å’†å“®", "prowl":"æ½œè¡Œ", "mouth":"å˜´å·´", "fright":"ææƒ§", "scream":"å°–å«",
  "must":"å¿…é¡»", "much":"å¾ˆå¤š", "will":"å°†è¦", "a":"ä¸€ä¸ª", "than":"æ¯”", "many":"è®¸å¤š", "cruel":"æ®‹å¿çš„", "dream":"æ¢¦æƒ³", "leaf":"æ ‘å¶", "breeze":"å¾®é£Ž",
  "gives":"ç»™", "they":"ä»–ä»¬", "dog":"ç‹—", "great":"ä¼Ÿå¤§çš„", "back":"èƒŒéƒ¨", "pears":"æ¢¨", "toast":"åå¸", "sweet":"ç”œçš„", "throws":"æ‰”", "catch":"æŠ“ä½",
  "sea":"æµ·", "head":"å¤´", "now":"çŽ°åœ¨", "across":"ç©¿è¿‡", "called":"è¢«å«", "scared":"å®³æ€•çš„", "asleep":"ç¡ç€çš„", "angry":"ç”Ÿæ°”çš„", "flew":"é£žäº†", "world":"ä¸–ç•Œ",
  "something":"æŸäº‹", "look":"çœ‹", "coming":"æ¥", "because":"å› ä¸º", "whole":"æ•´ä¸ª", "some":"ä¸€äº›", "love":"çˆ±", "feel":"æ„Ÿè§‰", "show":"å±•ç¤º", "short":"çŸ­çš„",
  "cold":"å†·çš„", "sleeping":"ç¡è§‰", "lived":"ç”Ÿæ´»", "if":"å¦‚æžœ", "go":"åŽ»", "hear":"å¬", "near":"é™„è¿‘", "bottom":"åº•éƒ¨", "behind":"åŽé¢", "sneak":"å·å·",
  "other":"å…¶ä»–", "cannot":"ä¸èƒ½", "never":"ä»Žä¸", "as":"ä½œä¸º", "two":"äºŒ", "together":"ä¸€èµ·", "again":"å†æ¬¡", "corner":"è§’è½", "teach":"æ•™", "watch":"è§‚çœ‹",
  "going":"åŽ»", "thought":"æƒ³æ³•", "soon":"å¾ˆå¿«", "got":"å¾—åˆ°", "keep":"ä¿æŒ", "change":"æ”¹å˜", "space":"ç©ºé—´", "stars":"æ˜Ÿæ˜Ÿ", "rocket":"ç«ç®­", "sky":"å¤©ç©º",
  "Mr":"å…ˆç”Ÿ", "morning":"æ—©æ™¨", "right":"æ­£ç¡®çš„", "know":"çŸ¥é“", "still":"ä»ç„¶", "happen":"å‘ç”Ÿ", "pretty":"æ¼‚äº®çš„", "beside":"åœ¨æ—è¾¹", "inside":"é‡Œé¢", "outside":"å¤–é¢",
  // G1
  "after":"ä¹‹åŽ", "again":"å†æ¬¡", "an":"ä¸€ä¸ª", "any":"ä»»ä½•", "as":"ä½œä¸º", "ask":"é—®", "by":"é€šè¿‡", "could":"èƒ½å¤Ÿ", "every":"æ¯ä¸ª", "fly":"é£ž", "from":"ä»Ž", "give":"ç»™", "going":"åŽ»", "had":"æœ‰äº†", "has":"æœ‰", "her":"å¥¹çš„", "him":"ä»–", "his":"ä»–çš„", "how":"æ€Žæ ·", "just":"åˆšåˆš", "know":"çŸ¥é“", "let":"è®©", "live":"ç”Ÿæ´»", "may":"å¯èƒ½", "of":"çš„", "old":"è€çš„", "once":"ä¸€æ¬¡", "open":"æ‰“å¼€", "over":"åœ¨...ä¸Šé¢", "put":"æ”¾", "round":"åœ†çš„", "some":"ä¸€äº›", "stop":"åœæ­¢", "take":"æ‹¿", "thank":"è°¢è°¢", "them":"ä»–ä»¬", "then":"ç„¶åŽ", "think":"æƒ³", "walk":"èµ°", "were":"æ˜¯", "when":"ä»€ä¹ˆæ—¶å€™",
  // G2
  "always":"æ€»æ˜¯", "around":"å‘¨å›´", "because":"å› ä¸º", "been":"æ˜¯", "before":"ä¹‹å‰", "best":"æœ€å¥½çš„", "both":"ä¸¤ä¸ªéƒ½", "buy":"ä¹°", "call":"å«", "cold":"å†·çš„", "does":"åš", "don't":"ä¸è¦", "fast":"å¿«çš„", "first":"ç¬¬ä¸€", "five":"äº”", "found":"æ‰¾åˆ°äº†", "gave":"ç»™äº†", "goes":"åŽ»", "green":"ç»¿è‰²", "its":"å®ƒçš„", "made":"åˆ¶ä½œäº†", "many":"è®¸å¤š", "off":"å…³", "or":"æˆ–è€…", "pull":"æ‹‰", "read":"è¯»", "right":"æ­£ç¡®çš„", "sing":"å”±æ­Œ", "sit":"å", "sleep":"ç¡è§‰", "tell":"å‘Šè¯‰", "their":"ä»–ä»¬çš„", "these":"è¿™äº›", "those":"é‚£äº›", "upon":"åœ¨...ä¹‹ä¸Š", "us":"æˆ‘ä»¬", "use":"ä½¿ç”¨", "very":"éžå¸¸", "wash":"æ´—", "which":"å“ªä¸ª", "why":"ä¸ºä»€ä¹ˆ", "wish":"å¸Œæœ›", "work":"å·¥ä½œ", "would":"ä¼š", "write":"å†™", "your":"ä½ çš„",
  // G3
  "about":"å…³äºŽ", "better":"æ›´å¥½çš„", "bring":"å¸¦æ¥", "carry":"æºå¸¦", "clean":"å¹²å‡€çš„", "cut":"åˆ‡", "done":"å®Œæˆ", "draw":"ç”»", "drink":"å–", "eight":"å…«", "fall":"ç§‹å¤©", "far":"è¿œçš„", "full":"æ»¡çš„", "got":"å¾—åˆ°äº†", "grow":"æˆé•¿", "hold":"æŠ“ä½", "hot":"çƒ­çš„", "hurt":"ä¼¤å®³", "if":"å¦‚æžœ", "keep":"ä¿æŒ", "kind":"å–„è‰¯çš„", "laugh":"ç¬‘", "light":"å…‰", "long":"é•¿çš„", "much":"å¾ˆå¤š", "myself":"æˆ‘è‡ªå·±", "never":"ä»Žä¸", "only":"åªæœ‰", "own":"è‡ªå·±çš„", "pick":"æŒ‘é€‰", "seven":"ä¸ƒ", "shall":"å°†è¦", "show":"æ˜¾ç¤º", "six":"å…­", "small":"å°çš„", "start":"å¼€å§‹", "ten":"å", "today":"ä»Šå¤©", "together":"ä¸€èµ·", "try":"å°è¯•", "warm":"æ¸©æš–çš„",
  // NOUNS
  "apple":"è‹¹æžœ", "baby":"å©´å„¿", "back":"èƒŒéƒ¨", "ball":"çƒ", "bear":"ç†Š", "bed":"åºŠ", "bell":"é“ƒ", "bird":"é¸Ÿ", "birthday":"ç”Ÿæ—¥", "boat":"èˆ¹", "box":"ç›’å­", "boy":"ç”·å­©", "bread":"é¢åŒ…", "brother":"å…„å¼Ÿ", "cake":"è›‹ç³•", "car":"æ±½è½¦", "cat":"çŒ«", "chair":"æ¤…å­", "chicken":"é¸¡", "children":"å­©å­ä»¬", "Christmas":"åœ£è¯žèŠ‚", "coat":"å¤–å¥—", "corn":"çŽ‰ç±³", "cow":"ç‰›", "day":"å¤©", "dog":"ç‹—", "doll":"å¨ƒå¨ƒ", "door":"é—¨", "duck":"é¸­å­", "egg":"è›‹", "eye":"çœ¼ç›", "farm":"å†œåœº", "farmer":"å†œæ°‘", "father":"çˆ¶äº²", "feet":"è„š", "fire":"ç«", "fish":"é±¼", "floor":"åœ°æ¿", "flower":"èŠ±", "game":"æ¸¸æˆ", "garden":"èŠ±å›­", "girl":"å¥³å­©", "goodbye":"å†è§", "grass":"è‰", "ground":"åœ°é¢", "hand":"æ‰‹", "head":"å¤´", "hill":"å±±ä¸˜", "home":"å®¶", "horse":"é©¬", "house":"æˆ¿å­", "kitty":"å°çŒ«", "leg":"è…¿", "letter":"å­—æ¯", "man":"ç”·äºº", "men":"ç”·äººä»¬", "milk":"ç‰›å¥¶", "money":"é’±", "morning":"æ—©æ™¨", "mother":"æ¯äº²", "name":"åå­—", "nest":"å·¢", "night":"å¤œæ™š", "paper":"çº¸", "party":"æ´¾å¯¹", "picture":"å›¾ç‰‡", "pig":"çŒª", "rabbit":"å…”å­", "rain":"é›¨", "ring":"æˆ’æŒ‡", "robin":"çŸ¥æ›´é¸Ÿ", "Santa Claus":"åœ£è¯žè€äºº", "school":"å­¦æ ¡", "seed":"ç§å­", "sheep":"ç¾Š", "shoe":"éž‹", "sister":"å§å¦¹", "snow":"é›ª", "song":"æ­Œ", "squirrel":"æ¾é¼ ", "stick":"æ£å­", "street":"è¡—é“", "sun":"å¤ªé˜³", "table":"æ¡Œå­", "thing":"ä¸œè¥¿", "time":"æ—¶é—´", "top":"é¡¶éƒ¨", "toy":"çŽ©å…·", "tree":"æ ‘", "watch":"æ‰‹è¡¨", "water":"æ°´", "way":"è·¯", "wind":"é£Ž", "window":"çª—æˆ·", "wood":"æœ¨å¤´"
};

const WORDS = [
  // New curriculum words - avoiding duplicates with existing G1-G3 and NOUNS
  ...["were","yes","may","or","an","tail","paws","fur","beak","feathers","around","animals","eyes","wish","then","growl","prowl","mouth","fright","scream","must","much","will","a","than","many","cruel","dream","leaf","breeze","gives","they","dog","great","back","pears","toast","sweet","throws","catch","sea","head","now","across","called","scared","asleep","angry","flew","world","something","look","coming","because","whole","some","love","feel","show","short","cold","sleeping","lived","if","go","hear","near","bottom","behind","sneak","other","cannot","never","as","two","together","again","corner","teach","watch","going","thought","soon","got","keep","change","space","stars","rocket","sky","Mr","morning","right","know","still","happen","pretty","beside","inside","outside"].filter(w => WORDS_WITH_TRANSLATIONS[w]).map(w=>({w,g:"NEW",t:WORDS_WITH_TRANSLATIONS[w]})),
  // Keep existing G1-G3 words that are not duplicated in new words
  ...["after","any","ask","by","could","every","fly","from","give","had","has","her","him","his","how","just","let","live","of","old","once","open","over","put","round","stop","take","thank","them","think","walk","when"].map(w=>({w,g:"G1",t:WORDS_WITH_TRANSLATIONS[w]})),
  ...["always","been","before","best","both","buy","call","does","don't","fast","first","five","found","gave","goes","green","its","made","off","pull","read","sing","sit","sleep","tell","their","these","those","upon","us","use","very","wash","which","why","work","would","write","your"].map(w=>({w,g:"G2",t:WORDS_WITH_TRANSLATIONS[w]})),
  ...["about","better","bring","carry","clean","cut","done","draw","drink","eight","fall","far","full","grow","hold","hot","hurt","kind","laugh","light","long","myself","only","own","pick","seven","shall","six","small","start","ten","today","try","warm"].map(w=>({w,g:"G3",t:WORDS_WITH_TRANSLATIONS[w]})),
  // Keep existing NOUNS that are not duplicated in new words 
  ...["apple","baby","ball","bear","bed","bell","bird","birthday","boat","box","boy","bread","brother","cake","car","cat","chair","chicken","children","Christmas","coat","corn","cow","day","doll","door","duck","egg","eye","farm","farmer","father","feet","fire","fish","floor","flower","game","garden","girl","goodbye","grass","ground","hand","hill","home","horse","house","kitty","leg","letter","man","men","milk","money","mother","name","nest","night","paper","party","picture","pig","rabbit","rain","ring","robin","Santa Claus","school","seed","sheep","shoe","sister","snow","song","squirrel","stick","street","sun","table","thing","time","top","toy","tree","water","way","wind","window","wood"].map(w=>({w,g:"NOUNS",t:WORDS_WITH_TRANSLATIONS[w]})),
];

// ---- Game State ----
let current = null;
let score = 0, streak = 0;
let autoNextTimer = null; // Auto next question timer
let usedWords = new Set(); // Track used words to avoid repetition

const $ = sel => document.querySelector(sel);
const $$ = sel => document.querySelectorAll(sel);

const elMask = $("#mask");
const elBank = $("#letterBank");
const elFeedback = $("#feedback");
const elStatus = $("#status");
const elCat = $("#cat");

// Safe DOM event binding with error handling
function bindEvents() {
  try {
    $("#next")?.addEventListener("click", newRound);
    $("#replay")?.addEventListener("click", () => {
      // Clear auto next timer
      if(autoNextTimer) {
        clearInterval(autoNextTimer);
        autoNextTimer = null;
      }
      current && setupRound(current.word, current.missingIdxs, current.translation);
    });
    $("#speak")?.addEventListener("click", ()=> current && speakWord(current.word));
    $("#showAnswer")?.addEventListener("click", showAnswer);
    
    // Bind word speak button when it becomes available
    setTimeout(() => {
      $("#wordSpeakBtn")?.addEventListener("click", ()=> current && speakWord(current.word));
    }, 100);
  } catch (error) {
    console.error("Error binding events:", error);
  }
}

// Call event binding
bindEvents();

// ---------- British TTS: Web Speech API ----------
let VOICES = [];
let UK_VOICE = null;

function loadVoices() {
  VOICES = window.speechSynthesis ? speechSynthesis.getVoices() : [];
  // Priority: High-quality English voices for clearer pronunciation
  UK_VOICE =
    // 1. Native English voices (premium quality)
    VOICES.find(v => v.lang && v.lang.toLowerCase() === "en-gb" && v.localService) ||
    VOICES.find(v => v.lang && v.lang.toLowerCase() === "en-us" && v.localService) ||
    // 2. Any English GB voices
    VOICES.find(v => v.lang && v.lang.toLowerCase() === "en-gb") ||
    // 3. Clear US voices as fallback
    VOICES.find(v => v.lang && v.lang.toLowerCase() === "en-us") ||
    // 4. Names containing quality indicators
    VOICES.find(v => /uk|british|english|samantha|alex|daniel|karen|moira/i.test(v.name)) ||
    // 5. Any English voice
    VOICES.find(v => /^en[-_]/i.test(v.lang)) || null;
  
  console.log('Selected voice:', UK_VOICE?.name, UK_VOICE?.lang, UK_VOICE?.localService ? '(Local)' : '(Network)');
  
  // Update speech button text based on available voice quality
  // Simplified button text without voice quality info
  const speakBtn = $("#speak");
  speakBtn.textContent = "ðŸ”Š Play Audio";
  speakBtn.title = "Play pronunciation";
  
  // Voice info display is hidden
}

// Some browsers (Chrome) need voiceschanged listener for complete voice list
if ('speechSynthesis' in window) {
  loadVoices();
  window.speechSynthesis.onvoiceschanged = loadVoices;
} else {
  // Disable button if not supported
  $("#speak").disabled = true;
  $("#speak").title = "Current browser doesn't support speech synthesis";
}

function speakWord(text){
  if(!('speechSynthesis' in window)) return;
  // Stop any ongoing speech
  speechSynthesis.cancel();
  
  // Add a small delay to ensure speech engine is ready
  setTimeout(() => {
    const u = new SpeechSynthesisUtterance();
    
    // Set voice for clearer pronunciation
    if (UK_VOICE) {
      u.voice = UK_VOICE;
      u.lang = UK_VOICE.lang;
    } else {
      u.lang = "en-US";  // Fallback to US English for better compatibility
    }
    
    // Normal mode settings
    u.rate = 0.8;     // Slightly slower than default
    u.pitch = 1.1;    // Slightly higher pitch for clarity
    u.volume = 1.0;
    u.text = text;
    
    speechSynthesis.speak(u);
  }, 100);  // 100ms delay before starting
}

// Show answer functionality
function showAnswer(){
  if(!current) return;
  const word = current.word;
  const missingIdxs = current.missingIdxs;
  
  // Fill correct answers into blank slots
  const holes = [...$$(".slot.hole")];
  const chars = [...word];
  holes.forEach((hole, index) => {
    const charIndex = parseInt(hole.dataset.idx);
    if(missingIdxs.has(charIndex)){
      hole.textContent = chars[charIndex].toLowerCase();
      hole.dataset.filled = "1";
      hole.dataset.letter = chars[charIndex].toLowerCase();
      // Add visual indicator for shown answer
      hole.style.backgroundColor = "#fff3cd";
      hole.style.border = "2px solid #ffc107";
    }
  });
  
  // Reset all letter buttons to unused state
  [...$$(".letters button")].forEach(btn => {
    btn.classList.remove("used");
  });
  
  // Show feedback
  elFeedback.innerHTML = "ðŸ’¡ Answer is: <span class='bigword'>"+word.toLowerCase()+"</span> (" + (current.translation || "") + ")";
  
  // Hide show answer button
  $("#showAnswer").style.display = "none";
}

// ---- Game Logic ----
function newRound(){
  try {
    // Clear any ongoing auto next timer
    if(autoNextTimer) {
      clearInterval(autoNextTimer);
      autoNextTimer = null;
    }
    // Hide show answer button
    const showAnswerBtn = $("#showAnswer");
    if(showAnswerBtn) showAnswerBtn.style.display = "none";
    
    // Filter out used words from the pool
    let availableWords = WORDS.filter(item => !usedWords.has(item.w));
    
    // If all words have been used, reset the used words set and start over
    if(availableWords.length === 0) {
      usedWords.clear();
      availableWords = WORDS.slice(); // Create a copy of all words
      console.log("All words completed! Starting new cycle.");
      // Show feedback to user about completing all words
      const feedback = $("#feedback");
      if(feedback) {
        feedback.innerHTML = "ðŸŽ‰ Congratulations! You've completed all " + WORDS.length + " words! Starting a new cycle...";
        setTimeout(() => {
          if(feedback) feedback.textContent = "";
        }, 3000);
      }
    }
    
    if(!availableWords.length){ 
      alert("No words available"); 
      return; 
    }
    
    const item = availableWords[Math.floor(Math.random()*availableWords.length)];
    if(!item || !item.w) {
      console.error("Invalid word item:", item);
      return;
    }
    
    // Add the selected word to used words set
    usedWords.add(item.w);
    
    const word = item.w.replace(/\s+/g,"");
    if(!word || word.length < 1) {
      console.error("Invalid word:", word);
      return;
    }
    
    // Standard difficulty: 2 letters for longer words, 1 letter for 2-letter words
    let holes;
    if (word.length <= 2) {
      holes = 1;  // Only remove 1 letter for very short words
    } else {
      holes = Math.min(2, word.length - 1);  // Remove 2 letters, but leave at least 1
    }
    const missingIdxs = makeMissingIndexes(word.length, holes);
    
    current = {word, missingIdxs, translation:item.t};
    setupRound(word, missingIdxs, item.t);
    
    // Update status with progress information
    const totalWords = WORDS.length;
    const completedWords = usedWords.size;
    elStatus.textContent = `Score ${score} | Streak ${streak} | Progress: ${completedWords}/${totalWords}`;
  } catch (error) {
    console.error("Error in newRound:", error);
    const feedback = $("#feedback");
    if(feedback) feedback.textContent = "Game error occurred. Please refresh the page.";
  }
}

// Dynamic slot sizing for mobile devices
function adjustSlotSizeForMobile(wordLength) {
  if (window.innerWidth <= 480) {
    const availableWidth = window.innerWidth - 72; // Account for padding and margins (60 * 1.2)
    const gapWidth = 10 * (wordLength - 1); // 10px gap between slots (8 * 1.2)
    const slotWidth = Math.floor((availableWidth - gapWidth) / wordLength);
    
    // Ensure minimum and maximum slot sizes (increased by 20%)
    const finalSlotWidth = Math.max(34, Math.min(53, slotWidth)); // 28*1.2=34, 44*1.2=53
    const fontSize = Math.max(19, Math.min(34, finalSlotWidth * 0.6)); // 16*1.2=19, 28*1.2=34
    const gapSize = Math.max(5, Math.min(10, finalSlotWidth * 0.15)); // 4*1.2=5, 8*1.2=10
    
    // Calculate total word width to determine if centering is possible
    const totalWordWidth = (finalSlotWidth * wordLength) + (gapSize * (wordLength - 1));
    const needsScroll = totalWordWidth > availableWidth;
    
    // Apply custom styles
    const style = document.createElement('style');
    style.id = 'dynamic-slot-style';
    
    // Remove existing dynamic style if it exists
    const existingStyle = document.getElementById('dynamic-slot-style');
    if (existingStyle) {
      existingStyle.remove();
    }
    
    style.textContent = `
      @media (max-width: 480px) {
        .slot {
          width: ${finalSlotWidth}px !important;
          height: ${Math.max(43, finalSlotWidth * 1.2)}px !important;
          font-size: ${fontSize}px !important;
        }
        .mask {
          gap: ${gapSize}px !important;
          justify-content: ${needsScroll ? 'flex-start' : 'center'} !important;
          ${needsScroll ? 'padding-left: 12px !important;' : ''}
        }
        .puzzle-container {
          align-items: center !important;
        }
      }
    `;
    
    document.head.appendChild(style);
  }
}

function setupRound(word, missingIdxs, translation){
  elMask.innerHTML = "";
  elBank.innerHTML = "";
  elFeedback.textContent = "";
  elCat.textContent = "Dolch Sight Words";
  // Hide show answer button
  $("#showAnswer").style.display = "none";
  // Clear any previous answer display styles
  [...$$(".slot")].forEach(slot => {
    slot.style.backgroundColor = "";
    slot.style.border = "";
  });
  // Clear any used button states from previous round
  [...$$(".letters button")].forEach(btn => {
    btn.classList.remove("used");
  });
  
  // Show game controls and translation
  const gameControls = $("#gameControls");
  const wordTranslation = $("#wordTranslation");
  
  if(gameControls) gameControls.style.display = "flex";
  if(wordTranslation) {
    wordTranslation.style.display = "block";
    wordTranslation.textContent = translation || current.translation || "";
  }
  
  // Dynamic slot sizing for mobile
  adjustSlotSizeForMobile(word.length);
  
  const chars = [...word];
  const missingLetters = [];

  chars.forEach((ch, i)=>{
    const div = document.createElement("div");
    div.className = "slot" + (missingIdxs.has(i) ? " hole" : "");
    if(missingIdxs.has(i)){
      div.dataset.idx = i;
      div.textContent = "â€”";
      div.addEventListener("click", ()=>{
        if(div.dataset.filled){
          // æ‰¾åˆ°å¯¹åº”çš„æŒ‰é’®å¹¶é‡æ–°å¯ç”¨
          const buttonId = div.dataset.buttonId;
          if(buttonId) {
            const correspondingBtn = [...$$(".letters button")].find(btn => btn.dataset.buttonId === buttonId);
            if(correspondingBtn) {
              correspondingBtn.classList.remove("used"); // ç§»é™¤å·²ä½¿ç”¨çŠ¶æ€ï¼Œé‡æ–°å¯ç”¨
            }
          }
          div.textContent = "â€”";
          div.dataset.filled = "";
          div.dataset.letter = "";
          div.dataset.buttonId = "";
        }
      });
      missingLetters.push(ch);
    } else {
      div.textContent = ch;
    }
    elMask.appendChild(div);
  });

  const distractors = makeDistractors(missingLetters, word);
  const bank = shuffle([...missingLetters, ...distractors]);
  bank.forEach(letter => addLetterToBank(letter));

  function addLetterToBank(letter){
    const btn = document.createElement("button");
    btn.textContent = letter.toLowerCase();
    btn.dataset.letter = letter.toLowerCase();
    btn.addEventListener("click", ()=>{
      if(btn.classList.contains("used")) return; // å·²è¢«ä½¿ç”¨çš„æŒ‰é’®ä¸èƒ½å†ç‚¹å‡»
      const hole = [...$$(".slot.hole")].find(s=>!s.dataset.filled);
      if(!hole) return;
      hole.textContent = letter.toLowerCase();
      hole.dataset.filled = "1";
      hole.dataset.letter = letter;
      hole.dataset.buttonId = btn.dataset.letter + "_" + Date.now(); // æ·»åŠ å”¯ä¸€æ ‡è¯†
      btn.dataset.buttonId = hole.dataset.buttonId; // æŒ‰é’®ä¹Ÿä¿å­˜ç›¸åŒæ ‡è¯†
      btn.classList.add("used"); // æ·»åŠ å·²ä½¿ç”¨çŠ¶æ€ï¼Œå˜æš—
      checkProgress();
    });
    elBank.appendChild(btn);
  }

  function checkProgress(){
    const filled = [...$$(".slot.hole")].every(s=>s.dataset.filled==="1");
    if(!filled) return;
    const guess = [...$$(".slot")].map(s=> (s.classList.contains("hole") ? (s.dataset.letter||"") : s.textContent)).join("").toLowerCase();
    const ok = guess === word.toLowerCase();
    if(ok){
      streak++; score += 10 + Math.max(0, (streak-1)*2);
      elFeedback.innerHTML = "âœ… Great! The word is <span class='bigword'>"+word.toLowerCase()+"</span> (" + (current.translation || "") + ")";
      $("#next").classList.add("good");
      setTimeout(()=>{$("#next").classList.remove("good")},600);
      // Hide show answer button when correct
      $("#showAnswer").style.display = "none";
      
      // Show countdown and auto next question
      let countdown = 3;
      autoNextTimer = setInterval(()=>{
        countdown--;
        if(countdown > 0){
          elFeedback.innerHTML = "âœ… Great! The word is <span class='bigword'>"+word.toLowerCase()+"</span> (" + (current.translation || "") + ")<br/>ðŸ“ " + countdown + " seconds until next question...";
        } else {
          clearInterval(autoNextTimer);
          autoNextTimer = null;
          newRound();
        }
      }, 1000);
    }else{
      streak=0; score = Math.max(0, score-2);
      elFeedback.innerHTML = "âŒ Try again! Click slots to remove letters.";
      $("#replay").classList.add("bad");
      setTimeout(()=>{$("#replay").classList.remove("bad")},600);
      // Show answer button after wrong answer
      $("#showAnswer").style.display = "inline-block";
    }
    // Update status with progress information
    const totalWords = WORDS.length;
    const completedWords = usedWords.size;
    elStatus.textContent = `Score ${score} | Streak ${streak} | Progress: ${completedWords}/${totalWords}`;
  }
}

function makeMissingIndexes(len, n){
  const idxs = new Set();
  
  // Calculate available positions (exclude first and last for words > 2 letters)
  let availablePositions = [];
  if(len <= 2) {
    // For very short words, allow any position except keeping at least 1
    availablePositions = [...Array(len).keys()];
  } else {
    // For longer words, exclude first and last positions
    availablePositions = [...Array(len).keys()].slice(1, -1);
  }
  
  // Limit n to available positions to prevent infinite loop
  const maxPossible = Math.min(n, availablePositions.length, len - 1);
  
  // Shuffle available positions for random selection
  const shuffledPositions = shuffle([...availablePositions]);
  
  // Select the required number of positions
  for(let i = 0; i < maxPossible; i++) {
    idxs.add(shuffledPositions[i]);
  }
  
  return idxs;
}

function makeDistractors(missingLetters, word){
  const alphabet = "abcdefghijklmnopqrstuvwxyz".split("");
  const need = Math.max(3, missingLetters.length);
  const pool = new Set();
  
  // Add neighboring letters for confusion
  word.split("").forEach(ch=>{
    const i = alphabet.indexOf(ch.toLowerCase());
    if(i>0) pool.add(alphabet[i-1]);
    if(i<alphabet.length-1) pool.add(alphabet[i+1]);
  });
  
  // Add random letters with safety limit to prevent infinite loop
  let attempts = 0;
  const maxAttempts = 100; // Safety limit
  while(pool.size < Math.min(need*2, 20) && attempts < maxAttempts){
    pool.add(alphabet[Math.floor(Math.random()*alphabet.length)]);
    attempts++;
  }
  
  // Remove letters that are already in the missing letters
  missingLetters.forEach(ch=> pool.delete(ch.toLowerCase()));
  
  // Return the needed number of distractors
  return shuffle([...pool]).slice(0, need);
}

function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

// Handle window resize for mobile optimization
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    if (current && current.word) {
      adjustSlotSizeForMobile(current.word.length);
    }
  }, 250);
});

// Start first question with error handling
setTimeout(() => {
  try {
    // Ensure DOM is ready and all elements are available
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => newRound());
    } else {
      newRound();
    }
  } catch (error) {
    console.error("Error starting game:", error);
    const feedback = $("#feedback");
    if(feedback) feedback.textContent = "Failed to start game. Please refresh the page.";
  }
}, 100);
</script>
</body>
</html>
