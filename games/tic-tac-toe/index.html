<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ellen' Tic Tac Toe Game</title>
<style>
  :root{
    --cell:48px;
    --gap:4px;
    --bg:#0e1116;
    --panel:#141a22;
    --fg:#e6edf3;
    --muted:#8693a0;
    --cell-bg:#1b2330;
    --btn-bg:#2a3443;
    --btn-border:#394457;
    --btn-hover:#334154;
    --status-bg:#1b2330;
    --bar-bg:#222b38;
  }
  
  :root[data-theme="light"]{
    --bg:#f8fafc;
    --panel:#ffffff;
    --fg:#1e293b;
    --muted:#64748b;
    --cell-bg:#f1f5f9;
    --btn-bg:#e2e8f0;
    --btn-border:#cbd5e1;
    --btn-hover:#cbd5e1;
    --status-bg:#f1f5f9;
    --bar-bg:#e2e8f0;
  }
  
  *{box-sizing:border-box} 
  body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;transition:background-color 0.3s,color 0.3s}
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px;display:grid;grid-template-columns:1fr 320px;gap:16px}
  header{grid-column:1/-1;margin-top:8px;margin-bottom:4px;display:flex;justify-content:space-between;align-items:center}
  h1{font-size:20px;margin:0 0 6px}
  .sub{color:var(--muted);font-size:13px}
  .theme-toggle{background:var(--btn-bg);color:var(--fg);border:1px solid var(--btn-border);border-radius:8px;padding:6px 12px;font:inherit;cursor:pointer;font-size:12px;transition:background-color 0.2s}
  .theme-toggle:hover{background:var(--btn-hover)}
  .board{display:grid;grid-template-columns:repeat(11,var(--cell));gap:var(--gap);padding:16px;background:var(--panel);border-radius:12px;align-self:start;transition:background-color 0.3s}
  .cell{width:var(--cell);height:var(--cell);border-radius:6px;background:var(--cell-bg);display:flex;align-items:center;justify-content:center;
        font-weight:700;font-size:20px;cursor:pointer;transition:transform .05s,background-color 0.3s}
  .cell:hover{transform:translateY(-1px)} .cell.disabled{cursor:not-allowed;opacity:.6}
  .cell.X{color:#5bd1a5} .cell.O{color:#f56565}
  
  :root[data-theme="light"] .cell.X{color:#059669}
  :root[data-theme="light"] .cell.O{color:#dc2626}
  
  .side{background:var(--panel);border-radius:12px;padding:14px;transition:background-color 0.3s}
  .row{display:flex;align-items:center;gap:10px;margin:10px 0}
  .row label{font-size:13px;color:var(--muted);min-width:72px}
  input[type=range]{width:100%}
  .status{margin:8px 0 12px;padding:10px;border-radius:10px;background:var(--status-bg);font-size:14px;transition:background-color 0.3s}
  .meta{color:var(--muted);font-size:12px}
  .bars{display:grid;gap:8px;margin-top:8px}
  .bar{height:12px;background:var(--bar-bg);border-radius:6px;overflow:hidden;transition:background-color 0.3s}
  .bar>span{display:block;height:100%}
  .bar.x>span{background:#5bd1a5} .bar.o>span{background:#f56565} .bar.d>span{background:#7f8ea3}
  .nums{display:flex;justify-content:space-between;font-size:13px;margin-top:6px;color:var(--muted)}
  .btns{display:flex;gap:8px;margin-top:6px}
  button{background:var(--btn-bg);color:var(--fg);border:1px solid var(--btn-border);border-radius:10px;padding:8px 10px;font:inherit;cursor:pointer;transition:all 0.2s}
  button:hover{background:var(--btn-hover)}
  button:disabled{opacity:0.5;cursor:not-allowed;background:var(--btn-bg)}
  button:disabled:hover{background:var(--btn-bg)}
  
  .confetti-container{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1000}
  .confetti{position:absolute;width:10px;height:10px;animation:confetti-fall 3s linear forwards}
  @keyframes confetti-fall{
    0%{transform:translateY(-10px) rotate(0deg);opacity:1}
    100%{transform:translateY(100vh) rotate(720deg);opacity:0}
  }
  
  .winner-cell{animation:winner-pulse 0.6s ease-in-out 3}
  @keyframes winner-pulse{
    0%,100%{transform:scale(1)}
    50%{transform:scale(1.1)}
  }
  
  @media (max-width:1000px){
    .wrap{
      grid-template-columns: 1fr;
      padding: 0 12px;
      margin: 16px auto;
    }
    
    header {
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
    }
    
    header > div:last-child {
      align-self: flex-end;
      margin-top: 0;
    }
    
    .theme-toggle {
      font-size: 11px;
      padding: 4px 8px;
    }
    
    h1 {
      font-size: 18px;
      margin-bottom: 4px;
    }
    
    :root {
      --cell: min(42px, 8vw);
      --gap: 3px;
    }
    
    .board {
      padding: 12px;
      border-radius: 10px;
    }
    
    .side {
      padding: 12px;
      border-radius: 10px;
    }
    
    .row {
      gap: 8px;
    }
    
    .row label {
      min-width: 64px;
      font-size: 12px;
    }
    
    .status {
      font-size: 13px;
      padding: 8px;
    }
    
    button {
      padding: 6px 8px;
      font-size: 13px;
    }
    
    .nums {
      font-size: 12px;
    }
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1 id="gameTitle">Ellen's Tic Tac Toe with Win Rate Analysis</h1>
      </div>
      <div style="display: flex; gap: 8px; align-items: center;">
        <button class="theme-toggle" id="languageToggle">🌐 中文</button>
        <button class="theme-toggle" id="themeToggle">☀️ Light Mode</button>
      </div>
    </header>

    <div class="board" id="board"></div>

    <aside class="side">
      <div class="status" id="status">Turn: <b id="turn">X</b></div>

      <div class="row">
        <label for="sims" id="simulationsLabel">Simulations</label>
        <input id="sims" type="range" min="500" max="5000" step="500" value="1500" />
        <span class="meta" id="simsVal">1500</span>
      </div>

      <div class="row">
        <label for="gameMode" id="gameModeLabel">游戏模式</label>
        <select id="gameMode" style="background:var(--btn-bg);color:var(--fg);border:1px solid var(--btn-border);border-radius:6px;padding:4px 8px;font:inherit;">
          <option value="pvp" id="pvpOption">双人对战</option>
          <option value="ai" id="aiOption">人机对战</option>
        </select>
      </div>

      <div class="row" id="difficultyRow" style="display:none;">
        <label for="aiDifficulty" id="difficultyLabel">AI难度</label>
        <select id="aiDifficulty" style="background:var(--btn-bg);color:var(--fg);border:1px solid var(--btn-border);border-radius:6px;padding:4px 8px;font:inherit;">
          <option value="easy" id="easyOption">简单</option>
          <option value="medium" id="mediumOption" selected>中等</option>
          <option value="hard" id="hardOption">困难</option>
        </select>
      </div>

      <div class="row">
        <label id="winConditionLabel">获胜条件</label>
        <span class="meta" id="winConditionDesc">玩家轮流点击放置棋子，连续放置5个子获胜</span>
      </div>

      <div class="btns">
        <button id="reset">New Game</button>
        <button id="undo">Undo Move</button>
        <button id="rerun">Re-estimate</button>
      </div>

      <div style="margin-top:14px">
        <div class="nums">
          <span id="xWinLabel">X Win: <b id="xPct">--%</b></span>
          <span id="oWinLabel">O Win: <b id="oPct">--%</b></span>
        </div>
        <div class="bars">
          <div class="bar x"><span id="xBar" style="width:0%"></span></div>
          <div class="bar o"><span id="oBar" style="width:0%"></span></div>
          <div class="bar d"><span id="dBar" style="width:0%"></span></div>
        </div>
        <div class="nums">
          <span id="drawLabel">Draw: <b id="dPct">--%</b></span>
          <span class="meta" id="timeInfo"></span>
        </div>
      </div>
    </aside>
  </div>

  <div class="confetti-container" id="confettiContainer"></div>

<script>
const SIZE = 11;
const CELLS = SIZE * SIZE;
let board = Array(CELLS).fill(null);
let nextPlayer = 'X';
let gameOver = false;
let isDarkMode = false;
let gameHistory = []; // 游戏历史记录
let gameMode = 'pvp'; // 游戏模式：'pvp' 或 'ai'
let aiPlayer = 'O'; // AI玩家标记，默认为O
let isAiThinking = false; // AI是否正在思考
let currentLanguage = 'en'; // 当前语言：'en' 或 'zh'
let aiDifficulty = 'medium'; // AI难度：'easy', 'medium', 'hard'

// LINES 生成保持不变，自动适配 SIZE
const LINES = (() => {
  const lines = [];
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c <= SIZE - 5; c++) {
      lines.push([r*SIZE+c, r*SIZE+c+1, r*SIZE+c+2, r*SIZE+c+3, r*SIZE+c+4]);
    }
  }
  for (let c = 0; c < SIZE; c++) {
    for (let r = 0; r <= SIZE - 5; r++) {
      lines.push([r*SIZE+c, (r+1)*SIZE+c, (r+2)*SIZE+c, (r+3)*SIZE+c, (r+4)*SIZE+c]);
    }
  }
  for (let r = 0; r <= SIZE - 5; r++) {
    for (let c = 0; c <= SIZE - 5; c++) {
      lines.push([r*SIZE+c, (r+1)*SIZE+c+1, (r+2)*SIZE+c+2, (r+3)*SIZE+c+3, (r+4)*SIZE+c+4]);
    }
  }
  for (let r = 0; r <= SIZE - 5; r++) {
    for (let c = 4; c < SIZE; c++) {
      lines.push([r*SIZE+c, (r+1)*SIZE+c-1, (r+2)*SIZE+c-2, (r+3)*SIZE+c-3, (r+4)*SIZE+c-4]);
    }
  }
  return lines;
})();

const boardEl = document.getElementById('board');
const turnEl = document.getElementById('turn');
const statusEl = document.getElementById('status');
const simsInput = document.getElementById('sims');
const simsVal = document.getElementById('simsVal');
const xPctEl = document.getElementById('xPct');
const oPctEl = document.getElementById('oPct');
const dPctEl = document.getElementById('dPct');
const xBar = document.getElementById('xBar');
const oBar = document.getElementById('oBar');
const dBar = document.getElementById('dBar');
const timeInfo = document.getElementById('timeInfo');
const themeToggle = document.getElementById('themeToggle');
const confettiContainer = document.getElementById('confettiContainer');
const gameModeSelect = document.getElementById('gameMode');
const aiDifficultySelect = document.getElementById('aiDifficulty');
const difficultyRow = document.getElementById('difficultyRow');
const languageToggle = document.getElementById('languageToggle');
const gameTitle = document.getElementById('gameTitle');

function toggleTheme() {
  isDarkMode = !isDarkMode;
  document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');
  updateThemeButtonText();
}

function updateThemeButtonText() {
  if (currentLanguage === 'zh') {
    themeToggle.textContent = isDarkMode ? '☀️ 浅色模式' : '🌙 深色模式';
  } else {
    themeToggle.textContent = isDarkMode ? '☀️ Light Mode' : '🌙 Dark Mode';
  }
}

function toggleLanguage() {
  currentLanguage = currentLanguage === 'en' ? 'zh' : 'en';
  updateTexts();
}

function updateTexts() {
  if (currentLanguage === 'zh') {
    gameTitle.textContent = 'Ellen的五子棋胜率分析游戏';
    languageToggle.textContent = '🌐 English';
    
    // 更新设置标签
    document.getElementById('simulationsLabel').textContent = '模拟次数';
    document.getElementById('gameModeLabel').textContent = '游戏模式';
    document.getElementById('pvpOption').textContent = '双人对战';
    document.getElementById('aiOption').textContent = '人机对战';
    document.getElementById('difficultyLabel').textContent = 'AI难度';
    document.getElementById('easyOption').textContent = '简单';
    document.getElementById('mediumOption').textContent = '中等';
    document.getElementById('hardOption').textContent = '困难';
    document.getElementById('winConditionLabel').textContent = '获胜条件';
    document.getElementById('winConditionDesc').textContent = '玩家轮流点击放置棋子，连续放置5个子获胜';
    
    // 更新按钮
    document.getElementById('reset').textContent = '新游戏';
    document.getElementById('undo').textContent = '悔棋';
    document.getElementById('rerun').textContent = '重新评估';
    
    // 更新统计标签
    updateStatsLabels('zh');
  } else {
    gameTitle.textContent = "Ellen's Tic Tac Toe with Win Rate Analysis";
    languageToggle.textContent = '🌐 中文';
    
    // 更新设置标签
    document.getElementById('simulationsLabel').textContent = 'Simulations';
    document.getElementById('gameModeLabel').textContent = 'Game Mode';
    document.getElementById('pvpOption').textContent = 'PvP Mode';
    document.getElementById('aiOption').textContent = 'AI Mode';
    document.getElementById('difficultyLabel').textContent = 'AI Difficulty';
    document.getElementById('easyOption').textContent = 'Easy';
    document.getElementById('mediumOption').textContent = 'Medium';
    document.getElementById('hardOption').textContent = 'Hard';
    document.getElementById('winConditionLabel').textContent = 'Win Condition';
    document.getElementById('winConditionDesc').textContent = 'Players take turns clicking to place their marks, 5 in a row to win';
    
    // 更新按钮
    document.getElementById('reset').textContent = 'New Game';
    document.getElementById('undo').textContent = 'Undo Move';
    document.getElementById('rerun').textContent = 'Re-estimate';
    
    // 更新统计标签
    updateStatsLabels('en');
  }
  updateThemeButtonText();
}

function updateStatsLabels(lang) {
  const xPct = document.getElementById('xPct').textContent;
  const oPct = document.getElementById('oPct').textContent;
  const dPct = document.getElementById('dPct').textContent;
  
  if (lang === 'zh') {
    document.getElementById('xWinLabel').innerHTML = `X胜: <b id="xPct">${xPct}</b>`;
    document.getElementById('oWinLabel').innerHTML = `O胜: <b id="oPct">${oPct}</b>`;
    document.getElementById('drawLabel').innerHTML = `平局: <b id="dPct">${dPct}</b>`;
  } else {
    document.getElementById('xWinLabel').innerHTML = `X Win: <b id="xPct">${xPct}</b>`;
    document.getElementById('oWinLabel').innerHTML = `O Win: <b id="oPct">${oPct}</b>`;
    document.getElementById('drawLabel').innerHTML = `Draw: <b id="dPct">${dPct}</b>`;
  }
}

function createConfetti() {
  const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'];
  const emojis = ['🎉', '🎊', '✨', '🌟', '💫', '🎈', '🎯', '🏆'];
  
  for (let i = 0; i < 50; i++) {
    const confetti = document.createElement('div');
    confetti.className = 'confetti';
    confetti.style.left = Math.random() * 100 + '%';
    confetti.style.animationDelay = Math.random() * 2 + 's';
    confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
    
    if (Math.random() > 0.5) {
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
    } else {
      confetti.textContent = emojis[Math.floor(Math.random() * emojis.length)];
      confetti.style.fontSize = '12px';
      confetti.style.display = 'flex';
      confetti.style.alignItems = 'center';
      confetti.style.justifyContent = 'center';
    }
    
    confettiContainer.appendChild(confetti);
    
    setTimeout(() => {
      if (confetti.parentNode) {
        confetti.parentNode.removeChild(confetti);
      }
    }, 5000);
  }
}

function highlightWinningCells(winningLine) {
  if (!winningLine) return;
  
  const cells = boardEl.children;
  winningLine.forEach(index => {
    cells[index].classList.add('winner-cell');
  });
  
  setTimeout(() => {
    winningLine.forEach(index => {
      cells[index].classList.remove('winner-cell');
    });
  }, 1800);
}

// 悔棋功能
function undoMove() {
  if (gameHistory.length === 0) return;
  
  let targetState;
  
  if (gameMode === 'ai') {
    // AI模式：恢复到玩家移动前的状态
    if (gameHistory.length >= 2) {
      // 恢复到倒数第二个状态（玩家移动前）
      targetState = gameHistory[gameHistory.length - 2];
      // 移除最后两个历史记录
      gameHistory.splice(-2, 2);
    } else if (gameHistory.length === 1) {
      // 只有一个历史记录时，恢复到初始状态
      targetState = null;
      gameHistory.splice(-1, 1);
    }
  } else {
    // PvP模式：恢复到上一步移动前的状态
    targetState = gameHistory[gameHistory.length - 1];
    gameHistory.pop();
  }
  
  // 恢复游戏状态
  if (targetState) {
    board = targetState.board.slice();
    nextPlayer = targetState.nextPlayer;
    gameOver = targetState.gameOver;
  } else {
    // 恢复到初始状态
    board = Array(CELLS).fill(null);
    nextPlayer = 'X';
    gameOver = false;
  }
  
  isAiThinking = false;
  updateStatusDisplay();
  renderBoard();
  estimateAndRender();
  updateUndoButton();
}

// 更新悔棋按钮状态
function updateUndoButton() {
  const undoBtn = document.getElementById('undo');
  undoBtn.disabled = gameHistory.length === 0;
}

function renderBoard() {
  boardEl.innerHTML = '';
  for (let i=0;i<CELLS;i++){
    const div = document.createElement('div');
    div.className = 'cell' + (board[i] ? ' '+board[i] : '');
    div.textContent = board[i] ?? '';
    if (!gameOver && !board[i] && !isAiThinking) {
      div.addEventListener('click', () => handleMove(i), {once:true});
    } else {
      div.classList.add('disabled');
    }
    boardEl.appendChild(div);
  }
  updateStatusDisplay();
}

function getAvailableMoves(b){ const m=[]; for(let i=0;i<b.length;i++) if(b[i]==null) m.push(i); return m; }

function getWinner(b) {
  for (const line of LINES) {
    const first = b[line[0]];
    if (!first) continue;
    let ok = true;
    for (let j=1;j<line.length;j++) if (b[line[j]] !== first) { ok=false; break; }
    if (ok) return {winner: first, line: line};
  }
  return null;
}

function isGameOver(b){ return !!getWinner(b) || getAvailableMoves(b).length===0; }

// 更新状态显示
function updateStatusDisplay() {
  if (gameOver) return;
  
  let displayText = '';
  if (gameMode === 'ai') {
    if (nextPlayer === aiPlayer) {
      displayText = currentLanguage === 'zh' ? `AI (${nextPlayer}) 思考中...` : `AI (${nextPlayer}) thinking...`;
      isAiThinking = true;
    } else {
      const turnText = currentLanguage === 'zh' ? '轮到' : 'Turn';
      const playerText = currentLanguage === 'zh' ? '玩家' : 'Player';
      displayText = `${turnText}: <b>${nextPlayer}</b> (${playerText})`;
      isAiThinking = false;
    }
  } else {
    const turnText = currentLanguage === 'zh' ? '轮到' : 'Turn';
    displayText = `${turnText}: <b>${nextPlayer}</b>`;
    isAiThinking = false;
  }
  statusEl.innerHTML = displayText;
}

// AI评分函数
function evaluatePosition(board, player) {
  const opponent = player === 'X' ? 'O' : 'X';
  let score = 0;
  
  // 检查所有可能的5连线
  for (const line of LINES) {
    let playerCount = 0;
    let opponentCount = 0;
    let emptyCount = 0;
    
    for (const pos of line) {
      if (board[pos] === player) playerCount++;
      else if (board[pos] === opponent) opponentCount++;
      else emptyCount++;
    }
    
    // 如果这条线有对手的子，就不能形成己方的5连
    if (opponentCount > 0 && playerCount > 0) continue;
    
    // 己方的连子评分
    if (playerCount > 0 && opponentCount === 0) {
      if (playerCount === 5) score += 100000;
      else if (playerCount === 4) score += 10000;
      else if (playerCount === 3) score += 1000;
      else if (playerCount === 2) score += 100;
      else if (playerCount === 1) score += 10;
    }
    
    // 对手的连子威胁评分（需要阻止）
    if (opponentCount > 0 && playerCount === 0) {
      if (opponentCount === 4) score -= 50000; // 必须阻止对手4连
      else if (opponentCount === 3) score -= 5000;
      else if (opponentCount === 2) score -= 500;
      else if (opponentCount === 1) score -= 50;
    }
  }
  
  return score;
}

// AI选择最佳移动（根据难度调整）
function getBestMove(board, player) {
  const moves = getAvailableMoves(board);
  if (moves.length === 0) return null;
  
  // 根据难度决定策略
  switch (aiDifficulty) {
    case 'easy':
      return getEasyMove(board, player, moves);
    case 'medium':
      return getMediumMove(board, player, moves);
    case 'hard':
      return getHardMove(board, player, moves);
    default:
      return getMediumMove(board, player, moves);
  }
}

// 简单难度：60%最佳移动，40%随机移动
function getEasyMove(board, player, moves) {
  // 如果是第一步，85%概率选择中心，15%随机
  if (moves.length === CELLS) {
    if (Math.random() < 0.85) {
      const center = Math.floor(SIZE / 2) * SIZE + Math.floor(SIZE / 2);
      return center;
    } else {
      return moves[Math.floor(Math.random() * moves.length)];
    }
  }
  
  // 总是检查获胜机会
  for (const move of moves) {
    const testBoard = board.slice();
    testBoard[move] = player;
    const winResult = getWinner(testBoard);
    if (winResult && winResult.winner === player) {
      return move; // 如果能获胜，总是选择获胜
    }
  }
  
  // 90%概率检查阻止对手获胜
  if (Math.random() < 0.9) {
    const opponent = player === 'X' ? 'O' : 'X';
    for (const move of moves) {
      const testBoard = board.slice();
      testBoard[move] = opponent;
      const opponentWin = getWinner(testBoard);
      if (opponentWin && opponentWin.winner === opponent) {
        return move; // 阻止对手获胜
      }
    }
  }
  
  // 60%概率选择最佳移动，40%随机移动
  if (Math.random() < 0.6) {
    return getHardMove(board, player, moves);
  } else {
    return moves[Math.floor(Math.random() * moves.length)];
  }
}

// 中等难度：70%最佳移动，30%次优移动
function getMediumMove(board, player, moves) {
  // 如果是第一步，选择中心位置
  if (moves.length === CELLS) {
    const center = Math.floor(SIZE / 2) * SIZE + Math.floor(SIZE / 2);
    return center;
  }
  
  // 总是检查获胜机会
  for (const move of moves) {
    const testBoard = board.slice();
    testBoard[move] = player;
    const winResult = getWinner(testBoard);
    if (winResult && winResult.winner === player) {
      return move;
    }
  }
  
  // 总是阻止对手获胜
  const opponent = player === 'X' ? 'O' : 'X';
  for (const move of moves) {
    const testBoard = board.slice();
    testBoard[move] = opponent;
    const opponentWin = getWinner(testBoard);
    if (opponentWin && opponentWin.winner === opponent) {
      return move;
    }
  }
  
  // 70%概率选择最佳移动
  if (Math.random() < 0.7) {
    return getHardMove(board, player, moves);
  } else {
    // 30%概率选择次优移动（随机选择前50%的好移动）
    const scoredMoves = moves.map(move => {
      const testBoard = board.slice();
      testBoard[move] = player;
      const score = evaluatePosition(testBoard, player);
      const row = Math.floor(move / SIZE);
      const col = move % SIZE;
      const centerRow = Math.floor(SIZE / 2);
      const centerCol = Math.floor(SIZE / 2);
      const distanceFromCenter = Math.abs(row - centerRow) + Math.abs(col - centerCol);
      const positionBonus = Math.max(0, 10 - distanceFromCenter);
      return { move, score: score + positionBonus };
    });
    
    scoredMoves.sort((a, b) => b.score - a.score);
    const topMoves = scoredMoves.slice(0, Math.max(1, Math.floor(scoredMoves.length * 0.5)));
    return topMoves[Math.floor(Math.random() * topMoves.length)].move;
  }
}

// 困难难度：总是选择最佳移动
function getHardMove(board, player, moves) {
  let bestMove = moves[0];
  let bestScore = -Infinity;
  
  // 如果是第一步，选择中心位置
  if (moves.length === CELLS) {
    const center = Math.floor(SIZE / 2) * SIZE + Math.floor(SIZE / 2);
    return center;
  }
  
  // 为每个可能的移动计算评分
  for (const move of moves) {
    const testBoard = board.slice();
    testBoard[move] = player;
    
    // 检查是否能直接获胜
    const winResult = getWinner(testBoard);
    if (winResult && winResult.winner === player) {
      return move; // 直接获胜
    }
    
    // 检查是否需要阻止对手获胜
    const opponent = player === 'X' ? 'O' : 'X';
    testBoard[move] = opponent;
    const opponentWin = getWinner(testBoard);
    if (opponentWin && opponentWin.winner === opponent) {
      testBoard[move] = player; // 恢复为AI的移动
      const score = evaluatePosition(testBoard, player) + 60000; // 阻止对手获胜的高分
      if (score > bestScore) {
        bestScore = score;
        bestMove = move;
      }
      continue;
    }
    
    // 正常评分
    testBoard[move] = player;
    const score = evaluatePosition(testBoard, player);
    
    // 位置奖励：更靠近中心的位置获得额外分数
    const row = Math.floor(move / SIZE);
    const col = move % SIZE;
    const centerRow = Math.floor(SIZE / 2);
    const centerCol = Math.floor(SIZE / 2);
    const distanceFromCenter = Math.abs(row - centerRow) + Math.abs(col - centerCol);
    const positionBonus = Math.max(0, 10 - distanceFromCenter);
    
    const finalScore = score + positionBonus;
    
    if (finalScore > bestScore) {
      bestScore = finalScore;
      bestMove = move;
    }
  }
  
  return bestMove;
}

// AI执行移动
function makeAiMove() {
  if (gameOver || nextPlayer !== aiPlayer) return;
  
  isAiThinking = true;
  updateStatusDisplay();
  renderBoard();
  
  // 使用setTimeout来模拟AI思考时间（根据难度调整）
  let thinkingTime;
  switch (aiDifficulty) {
    case 'easy':
      thinkingTime = 500 + Math.random() * 400; // 500-900ms
      break;
    case 'medium':
      thinkingTime = 600 + Math.random() * 400; // 600-1000ms
      break;
    case 'hard':
      thinkingTime = 800 + Math.random() * 500; // 800-1300ms
      break;
    default:
      thinkingTime = 600 + Math.random() * 400;
  }
  
  setTimeout(() => {
    const bestMove = getBestMove(board, aiPlayer);
    if (bestMove !== null) {
      handleMove(bestMove, true);
    }
    isAiThinking = false;
  }, thinkingTime);
}

function handleMove(idx, isAiMove = false){
  if (gameOver || board[idx] || (gameMode === 'ai' && !isAiMove && nextPlayer === aiPlayer)) return;
  
  // 保存当前状态到历史记录
  gameHistory.push({
    board: board.slice(), // 创建棋盘副本
    nextPlayer: nextPlayer,
    gameOver: gameOver
  });
  
  board[idx] = nextPlayer;
  const winnerResult = getWinner(board);
  if (winnerResult) {
    gameOver = true;
    const winnerText = gameMode === 'ai' && winnerResult.winner === aiPlayer ? 'AI' : winnerResult.winner;
    const gameOverText = currentLanguage === 'zh' ? '游戏结束' : 'Game Over';
    const winsText = currentLanguage === 'zh' ? '获胜！' : 'Wins!';
    statusEl.innerHTML = `${gameOverText}: <b>${winnerText}</b> ${winsText}`;
    createConfetti();
    highlightWinningCells(winnerResult.line);
  } else if (getAvailableMoves(board).length===0) {
    gameOver = true;
    const gameOverText = currentLanguage === 'zh' ? '游戏结束' : 'Game Over';
    const drawText = currentLanguage === 'zh' ? '平局！' : 'Draw!';
    statusEl.textContent = `${gameOverText}: ${drawText}`;
  } else {
    nextPlayer = nextPlayer==='X' ? 'O' : 'X';
    updateStatusDisplay();
  }
  renderBoard();
  estimateAndRender();
  updateUndoButton();
  
  // 在人机模式下，如果轮到AI，自动执行AI移动
  if (gameMode === 'ai' && !gameOver && nextPlayer === aiPlayer) {
    setTimeout(() => makeAiMove(), 500); // 延迟500ms让用户看到变化
  }
}

function playRandomGame(b, player){
  while(true){
    const winner = getWinner(b);
    if (winner) return winner.winner;
    const moves = getAvailableMoves(b);
    if (moves.length===0) return null;
    const move = moves[(Math.random()*moves.length)|0];
    b[move] = player;
    player = player==='X' ? 'O' : 'X';
  }
}

function simulateWinRate(b, player, simulations=1500){
  let xWins=0, oWins=0, draws=0;
  for (let i=0;i<simulations;i++){
    const copy = b.slice();
    const res = playRandomGame(copy, player);
    if (res==='X') xWins++;
    else if (res==='O') oWins++;
    else draws++;
  }
  return {
    x: xWins/simulations,
    o: oWins/simulations,
    d: draws/simulations
  };
}

function estimateAndRender(){
  const sims = +simsInput.value;
  simsVal.textContent = sims;
  const t0 = performance.now();
  if (gameOver){
    const w = getWinner(board);
    const rates = w ? (w.winner==='X'?{x:1,o:0,d:0}:{x:0,o:1,d:0}) : {x:0,o:0,d:1};
    updateBars(rates, 0);
    return;
  }
  requestAnimationFrame(()=>{
    const rates = simulateWinRate(board, nextPlayer, sims);
    const t1 = performance.now();
    updateBars(rates, t1 - t0);
  });
}

function updateBars(rates, ms){
  const toPct = v => Math.round(v*100);
  const xPct = toPct(rates.x) + '%';
  const oPct = toPct(rates.o) + '%';
  const dPct = toPct(rates.d) + '%';
  
  xPctEl.textContent = xPct;
  oPctEl.textContent = oPct;
  dPctEl.textContent = dPct;
  xBar.style.width = (rates.x*100) + '%';
  oBar.style.width = (rates.o*100) + '%';
  dBar.style.width = (rates.d*100) + '%';
  timeInfo.textContent = ms ? `${Math.round(ms)}ms` : '';
  
  // 更新带语言的标签
  if (currentLanguage === 'zh') {
    document.getElementById('xWinLabel').innerHTML = `X胜: <b id="xPct">${xPct}</b>`;
    document.getElementById('oWinLabel').innerHTML = `O胜: <b id="oPct">${oPct}</b>`;
    document.getElementById('drawLabel').innerHTML = `平局: <b id="dPct">${dPct}</b>`;
  } else {
    document.getElementById('xWinLabel').innerHTML = `X Win: <b id="xPct">${xPct}</b>`;
    document.getElementById('oWinLabel').innerHTML = `O Win: <b id="oPct">${oPct}</b>`;
    document.getElementById('drawLabel').innerHTML = `Draw: <b id="dPct">${dPct}</b>`;
  }
}

simsInput.addEventListener('input', ()=>{ simsVal.textContent = simsInput.value; });
document.getElementById('rerun').addEventListener('click', estimateAndRender);
document.getElementById('undo').addEventListener('click', undoMove);
document.getElementById('reset').addEventListener('click', ()=>{
  board = Array(CELLS).fill(null);
  nextPlayer = 'X';
  gameOver = false;
  gameHistory = []; // 清空历史记录
  isAiThinking = false;
  updateStatusDisplay();
  renderBoard();
  estimateAndRender();
  updateUndoButton();
});

// 游戏模式切换事件
gameModeSelect.addEventListener('change', (e) => {
  gameMode = e.target.value;
  
  // 显示或隐藏难度选择器
  if (gameMode === 'ai') {
    difficultyRow.style.display = 'flex';
  } else {
    difficultyRow.style.display = 'none';
  }
  
  // 重置游戏
  board = Array(CELLS).fill(null);
  nextPlayer = 'X';
  gameOver = false;
  gameHistory = [];
  isAiThinking = false;
  
  // 在AI模式下，AI总是扮演O
  aiPlayer = 'O';
  
  updateStatusDisplay();
  renderBoard();
  estimateAndRender();
  updateUndoButton();
});

// AI难度切换事件
aiDifficultySelect.addEventListener('change', (e) => {
  aiDifficulty = e.target.value;
  // 不需要重置游戏，只是改变AI策略
});
themeToggle.addEventListener('click', toggleTheme);
languageToggle.addEventListener('click', toggleLanguage);

renderBoard();
estimateAndRender();
updateUndoButton();

// 初始化游戏模式
gameMode = gameModeSelect.value;
aiDifficulty = aiDifficultySelect.value;

// 根据初始游戏模式显示或隐藏难度选择器
if (gameMode === 'ai') {
  difficultyRow.style.display = 'flex';
} else {
  difficultyRow.style.display = 'none';
}

// 初始化主题为浅色模式
document.documentElement.setAttribute('data-theme', 'light');

// 初始化语言为中文
currentLanguage = 'zh';
updateTexts();
updateStatusDisplay();

</script>
</body>
</html>
