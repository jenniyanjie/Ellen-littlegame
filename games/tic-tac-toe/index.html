<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ellen' Tic Tac Toe Game</title>
<style>
  :root{
    --cell:48px;
    --gap:4px;
    --bg:#0e1116;
    --panel:#141a22;
    --fg:#e6edf3;
    --muted:#8693a0;
    --cell-bg:#1b2330;
    --btn-bg:#2a3443;
    --btn-border:#394457;
    --btn-hover:#334154;
    --status-bg:#1b2330;
    --bar-bg:#222b38;
  }
  
  :root[data-theme="light"]{
    --bg:#f8fafc;
    --panel:#ffffff;
    --fg:#1e293b;
    --muted:#64748b;
    --cell-bg:#f1f5f9;
    --btn-bg:#e2e8f0;
    --btn-border:#cbd5e1;
    --btn-hover:#cbd5e1;
    --status-bg:#f1f5f9;
    --bar-bg:#e2e8f0;
  }
  
  *{box-sizing:border-box} 
  body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;transition:background-color 0.3s,color 0.3s}
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px;display:grid;grid-template-columns:1fr 320px;gap:16px}
  header{grid-column:1/-1;margin-top:8px;margin-bottom:4px;display:flex;justify-content:space-between;align-items:center}
  h1{font-size:20px;margin:0 0 6px}
  .sub{color:var(--muted);font-size:13px}
  .theme-toggle{background:var(--btn-bg);color:var(--fg);border:1px solid var(--btn-border);border-radius:8px;padding:6px 12px;font:inherit;cursor:pointer;font-size:12px;transition:background-color 0.2s}
  .theme-toggle:hover{background:var(--btn-hover)}
  .board{display:grid;grid-template-columns:repeat(11,var(--cell));gap:var(--gap);padding:16px;background:var(--panel);border-radius:12px;align-self:start;transition:background-color 0.3s}
  .cell{width:var(--cell);height:var(--cell);border-radius:6px;background:var(--cell-bg);display:flex;align-items:center;justify-content:center;
        font-weight:700;font-size:20px;cursor:pointer;transition:transform .05s,background-color 0.3s}
  .cell:hover{transform:translateY(-1px)} .cell.disabled{cursor:not-allowed;opacity:.6}
  .cell.X{color:#5bd1a5} .cell.O{color:#f56565}
  
  :root[data-theme="light"] .cell.X{color:#059669}
  :root[data-theme="light"] .cell.O{color:#dc2626}
  
  .side{background:var(--panel);border-radius:12px;padding:14px;transition:background-color 0.3s}
  .row{display:flex;align-items:center;gap:10px;margin:10px 0}
  .row label{font-size:13px;color:var(--muted);min-width:72px}
  input[type=range]{width:100%}
  .status{margin:8px 0 12px;padding:10px;border-radius:10px;background:var(--status-bg);font-size:14px;transition:background-color 0.3s}
  .meta{color:var(--muted);font-size:12px}
  .bars{display:grid;gap:8px;margin-top:8px}
  .bar{height:12px;background:var(--bar-bg);border-radius:6px;overflow:hidden;transition:background-color 0.3s}
  .bar>span{display:block;height:100%}
  .bar.x>span{background:#5bd1a5} .bar.o>span{background:#f56565} .bar.d>span{background:#7f8ea3}
  .nums{display:flex;justify-content:space-between;font-size:13px;margin-top:6px;color:var(--muted)}
  .btns{display:flex;gap:8px;margin-top:6px}
  button{background:var(--btn-bg);color:var(--fg);border:1px solid var(--btn-border);border-radius:10px;padding:8px 10px;font:inherit;cursor:pointer;transition:all 0.2s}
  button:hover{background:var(--btn-hover)}
  button:disabled{opacity:0.5;cursor:not-allowed;background:var(--btn-bg)}
  button:disabled:hover{background:var(--btn-bg)}
  
  .confetti-container{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1000}
  .confetti{position:absolute;width:10px;height:10px;animation:confetti-fall 3s linear forwards}
  @keyframes confetti-fall{
    0%{transform:translateY(-10px) rotate(0deg);opacity:1}
    100%{transform:translateY(100vh) rotate(720deg);opacity:0}
  }
  
  .winner-cell{animation:winner-pulse 0.6s ease-in-out 3}
  @keyframes winner-pulse{
    0%,100%{transform:scale(1)}
    50%{transform:scale(1.1)}
  }
  
  @media (max-width:1000px){
    .wrap{
      grid-template-columns: 1fr;
      padding: 0 12px;
      margin: 16px auto;
    }
    
    header {
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
    }
    
    header > div:last-child {
      align-self: flex-end;
      margin-top: 0;
    }
    
    .theme-toggle {
      font-size: 11px;
      padding: 4px 8px;
    }
    
    h1 {
      font-size: 18px;
      margin-bottom: 4px;
    }
    
    :root {
      --cell: min(42px, 8vw);
      --gap: 3px;
    }
    
    .board {
      padding: 12px;
      border-radius: 10px;
    }
    
    .side {
      padding: 12px;
      border-radius: 10px;
    }
    
    .row {
      gap: 8px;
    }
    
    .row label {
      min-width: 64px;
      font-size: 12px;
    }
    
    .status {
      font-size: 13px;
      padding: 8px;
    }
    
    button {
      padding: 6px 8px;
      font-size: 13px;
    }
    
    .nums {
      font-size: 12px;
    }
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1 id="gameTitle">Ellen's Tic Tac Toe with Win Rate Analysis</h1>
      </div>
      <div style="display: flex; gap: 8px; align-items: center;">
        <button class="theme-toggle" id="languageToggle">ğŸŒ ä¸­æ–‡</button>
        <button class="theme-toggle" id="themeToggle">â˜€ï¸ Light Mode</button>
      </div>
    </header>

    <div class="board" id="board"></div>

    <aside class="side">
      <div class="status" id="status">Turn: <b id="turn">X</b></div>

      <div class="row">
        <label for="sims" id="simulationsLabel">Simulations</label>
        <input id="sims" type="range" min="500" max="5000" step="500" value="1500" />
        <span class="meta" id="simsVal">1500</span>
      </div>

      <div class="row">
        <label for="gameMode" id="gameModeLabel">æ¸¸æˆæ¨¡å¼</label>
        <select id="gameMode" style="background:var(--btn-bg);color:var(--fg);border:1px solid var(--btn-border);border-radius:6px;padding:4px 8px;font:inherit;">
          <option value="pvp" id="pvpOption">åŒäººå¯¹æˆ˜</option>
          <option value="ai" id="aiOption">äººæœºå¯¹æˆ˜</option>
        </select>
      </div>

      <div class="row" id="difficultyRow" style="display:none;">
        <label for="aiDifficulty" id="difficultyLabel">AIéš¾åº¦</label>
        <select id="aiDifficulty" style="background:var(--btn-bg);color:var(--fg);border:1px solid var(--btn-border);border-radius:6px;padding:4px 8px;font:inherit;">
          <option value="easy" id="easyOption">ç®€å•</option>
          <option value="medium" id="mediumOption" selected>ä¸­ç­‰</option>
          <option value="hard" id="hardOption">å›°éš¾</option>
        </select>
      </div>

      <div class="row">
        <label id="winConditionLabel">è·èƒœæ¡ä»¶</label>
        <span class="meta" id="winConditionDesc">ç©å®¶è½®æµç‚¹å‡»æ”¾ç½®æ£‹å­ï¼Œè¿ç»­æ”¾ç½®5ä¸ªå­è·èƒœ</span>
      </div>

      <div class="btns">
        <button id="reset">New Game</button>
        <button id="undo">Undo Move</button>
        <button id="rerun">Re-estimate</button>
      </div>

      <div style="margin-top:14px">
        <div class="nums">
          <span id="xWinLabel">X Win: <b id="xPct">--%</b></span>
          <span id="oWinLabel">O Win: <b id="oPct">--%</b></span>
        </div>
        <div class="bars">
          <div class="bar x"><span id="xBar" style="width:0%"></span></div>
          <div class="bar o"><span id="oBar" style="width:0%"></span></div>
          <div class="bar d"><span id="dBar" style="width:0%"></span></div>
        </div>
        <div class="nums">
          <span id="drawLabel">Draw: <b id="dPct">--%</b></span>
          <span class="meta" id="timeInfo"></span>
        </div>
      </div>
    </aside>
  </div>

  <div class="confetti-container" id="confettiContainer"></div>

<script>
const SIZE = 11;
const CELLS = SIZE * SIZE;
let board = Array(CELLS).fill(null);
let nextPlayer = 'X';
let gameOver = false;
let isDarkMode = false;
let gameHistory = []; // æ¸¸æˆå†å²è®°å½•
let gameMode = 'pvp'; // æ¸¸æˆæ¨¡å¼ï¼š'pvp' æˆ– 'ai'
let aiPlayer = 'O'; // AIç©å®¶æ ‡è®°ï¼Œé»˜è®¤ä¸ºO
let isAiThinking = false; // AIæ˜¯å¦æ­£åœ¨æ€è€ƒ
let currentLanguage = 'en'; // å½“å‰è¯­è¨€ï¼š'en' æˆ– 'zh'
let aiDifficulty = 'medium'; // AIéš¾åº¦ï¼š'easy', 'medium', 'hard'

// LINES ç”Ÿæˆä¿æŒä¸å˜ï¼Œè‡ªåŠ¨é€‚é… SIZE
const LINES = (() => {
  const lines = [];
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c <= SIZE - 5; c++) {
      lines.push([r*SIZE+c, r*SIZE+c+1, r*SIZE+c+2, r*SIZE+c+3, r*SIZE+c+4]);
    }
  }
  for (let c = 0; c < SIZE; c++) {
    for (let r = 0; r <= SIZE - 5; r++) {
      lines.push([r*SIZE+c, (r+1)*SIZE+c, (r+2)*SIZE+c, (r+3)*SIZE+c, (r+4)*SIZE+c]);
    }
  }
  for (let r = 0; r <= SIZE - 5; r++) {
    for (let c = 0; c <= SIZE - 5; c++) {
      lines.push([r*SIZE+c, (r+1)*SIZE+c+1, (r+2)*SIZE+c+2, (r+3)*SIZE+c+3, (r+4)*SIZE+c+4]);
    }
  }
  for (let r = 0; r <= SIZE - 5; r++) {
    for (let c = 4; c < SIZE; c++) {
      lines.push([r*SIZE+c, (r+1)*SIZE+c-1, (r+2)*SIZE+c-2, (r+3)*SIZE+c-3, (r+4)*SIZE+c-4]);
    }
  }
  return lines;
})();

const boardEl = document.getElementById('board');
const turnEl = document.getElementById('turn');
const statusEl = document.getElementById('status');
const simsInput = document.getElementById('sims');
const simsVal = document.getElementById('simsVal');
const xPctEl = document.getElementById('xPct');
const oPctEl = document.getElementById('oPct');
const dPctEl = document.getElementById('dPct');
const xBar = document.getElementById('xBar');
const oBar = document.getElementById('oBar');
const dBar = document.getElementById('dBar');
const timeInfo = document.getElementById('timeInfo');
const themeToggle = document.getElementById('themeToggle');
const confettiContainer = document.getElementById('confettiContainer');
const gameModeSelect = document.getElementById('gameMode');
const aiDifficultySelect = document.getElementById('aiDifficulty');
const difficultyRow = document.getElementById('difficultyRow');
const languageToggle = document.getElementById('languageToggle');
const gameTitle = document.getElementById('gameTitle');

function toggleTheme() {
  isDarkMode = !isDarkMode;
  document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');
  updateThemeButtonText();
}

function updateThemeButtonText() {
  if (currentLanguage === 'zh') {
    themeToggle.textContent = isDarkMode ? 'â˜€ï¸ æµ…è‰²æ¨¡å¼' : 'ğŸŒ™ æ·±è‰²æ¨¡å¼';
  } else {
    themeToggle.textContent = isDarkMode ? 'â˜€ï¸ Light Mode' : 'ğŸŒ™ Dark Mode';
  }
}

function toggleLanguage() {
  currentLanguage = currentLanguage === 'en' ? 'zh' : 'en';
  updateTexts();
}

function updateTexts() {
  if (currentLanguage === 'zh') {
    gameTitle.textContent = 'Ellençš„äº”å­æ£‹èƒœç‡åˆ†ææ¸¸æˆ';
    languageToggle.textContent = 'ğŸŒ English';
    
    // æ›´æ–°è®¾ç½®æ ‡ç­¾
    document.getElementById('simulationsLabel').textContent = 'æ¨¡æ‹Ÿæ¬¡æ•°';
    document.getElementById('gameModeLabel').textContent = 'æ¸¸æˆæ¨¡å¼';
    document.getElementById('pvpOption').textContent = 'åŒäººå¯¹æˆ˜';
    document.getElementById('aiOption').textContent = 'äººæœºå¯¹æˆ˜';
    document.getElementById('difficultyLabel').textContent = 'AIéš¾åº¦';
    document.getElementById('easyOption').textContent = 'ç®€å•';
    document.getElementById('mediumOption').textContent = 'ä¸­ç­‰';
    document.getElementById('hardOption').textContent = 'å›°éš¾';
    document.getElementById('winConditionLabel').textContent = 'è·èƒœæ¡ä»¶';
    document.getElementById('winConditionDesc').textContent = 'ç©å®¶è½®æµç‚¹å‡»æ”¾ç½®æ£‹å­ï¼Œè¿ç»­æ”¾ç½®5ä¸ªå­è·èƒœ';
    
    // æ›´æ–°æŒ‰é’®
    document.getElementById('reset').textContent = 'æ–°æ¸¸æˆ';
    document.getElementById('undo').textContent = 'æ‚”æ£‹';
    document.getElementById('rerun').textContent = 'é‡æ–°è¯„ä¼°';
    
    // æ›´æ–°ç»Ÿè®¡æ ‡ç­¾
    updateStatsLabels('zh');
  } else {
    gameTitle.textContent = "Ellen's Tic Tac Toe with Win Rate Analysis";
    languageToggle.textContent = 'ğŸŒ ä¸­æ–‡';
    
    // æ›´æ–°è®¾ç½®æ ‡ç­¾
    document.getElementById('simulationsLabel').textContent = 'Simulations';
    document.getElementById('gameModeLabel').textContent = 'Game Mode';
    document.getElementById('pvpOption').textContent = 'PvP Mode';
    document.getElementById('aiOption').textContent = 'AI Mode';
    document.getElementById('difficultyLabel').textContent = 'AI Difficulty';
    document.getElementById('easyOption').textContent = 'Easy';
    document.getElementById('mediumOption').textContent = 'Medium';
    document.getElementById('hardOption').textContent = 'Hard';
    document.getElementById('winConditionLabel').textContent = 'Win Condition';
    document.getElementById('winConditionDesc').textContent = 'Players take turns clicking to place their marks, 5 in a row to win';
    
    // æ›´æ–°æŒ‰é’®
    document.getElementById('reset').textContent = 'New Game';
    document.getElementById('undo').textContent = 'Undo Move';
    document.getElementById('rerun').textContent = 'Re-estimate';
    
    // æ›´æ–°ç»Ÿè®¡æ ‡ç­¾
    updateStatsLabels('en');
  }
  updateThemeButtonText();
}

function updateStatsLabels(lang) {
  const xPct = document.getElementById('xPct').textContent;
  const oPct = document.getElementById('oPct').textContent;
  const dPct = document.getElementById('dPct').textContent;
  
  if (lang === 'zh') {
    document.getElementById('xWinLabel').innerHTML = `Xèƒœ: <b id="xPct">${xPct}</b>`;
    document.getElementById('oWinLabel').innerHTML = `Oèƒœ: <b id="oPct">${oPct}</b>`;
    document.getElementById('drawLabel').innerHTML = `å¹³å±€: <b id="dPct">${dPct}</b>`;
  } else {
    document.getElementById('xWinLabel').innerHTML = `X Win: <b id="xPct">${xPct}</b>`;
    document.getElementById('oWinLabel').innerHTML = `O Win: <b id="oPct">${oPct}</b>`;
    document.getElementById('drawLabel').innerHTML = `Draw: <b id="dPct">${dPct}</b>`;
  }
}

function createConfetti() {
  const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'];
  const emojis = ['ğŸ‰', 'ğŸŠ', 'âœ¨', 'ğŸŒŸ', 'ğŸ’«', 'ğŸˆ', 'ğŸ¯', 'ğŸ†'];
  
  for (let i = 0; i < 50; i++) {
    const confetti = document.createElement('div');
    confetti.className = 'confetti';
    confetti.style.left = Math.random() * 100 + '%';
    confetti.style.animationDelay = Math.random() * 2 + 's';
    confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
    
    if (Math.random() > 0.5) {
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
    } else {
      confetti.textContent = emojis[Math.floor(Math.random() * emojis.length)];
      confetti.style.fontSize = '12px';
      confetti.style.display = 'flex';
      confetti.style.alignItems = 'center';
      confetti.style.justifyContent = 'center';
    }
    
    confettiContainer.appendChild(confetti);
    
    setTimeout(() => {
      if (confetti.parentNode) {
        confetti.parentNode.removeChild(confetti);
      }
    }, 5000);
  }
}

function highlightWinningCells(winningLine) {
  if (!winningLine) return;
  
  const cells = boardEl.children;
  winningLine.forEach(index => {
    cells[index].classList.add('winner-cell');
  });
  
  setTimeout(() => {
    winningLine.forEach(index => {
      cells[index].classList.remove('winner-cell');
    });
  }, 1800);
}

// æ‚”æ£‹åŠŸèƒ½
function undoMove() {
  if (gameHistory.length === 0) return;
  
  let targetState;
  
  if (gameMode === 'ai') {
    // AIæ¨¡å¼ï¼šæ¢å¤åˆ°ç©å®¶ç§»åŠ¨å‰çš„çŠ¶æ€
    if (gameHistory.length >= 2) {
      // æ¢å¤åˆ°å€’æ•°ç¬¬äºŒä¸ªçŠ¶æ€ï¼ˆç©å®¶ç§»åŠ¨å‰ï¼‰
      targetState = gameHistory[gameHistory.length - 2];
      // ç§»é™¤æœ€åä¸¤ä¸ªå†å²è®°å½•
      gameHistory.splice(-2, 2);
    } else if (gameHistory.length === 1) {
      // åªæœ‰ä¸€ä¸ªå†å²è®°å½•æ—¶ï¼Œæ¢å¤åˆ°åˆå§‹çŠ¶æ€
      targetState = null;
      gameHistory.splice(-1, 1);
    }
  } else {
    // PvPæ¨¡å¼ï¼šæ¢å¤åˆ°ä¸Šä¸€æ­¥ç§»åŠ¨å‰çš„çŠ¶æ€
    targetState = gameHistory[gameHistory.length - 1];
    gameHistory.pop();
  }
  
  // æ¢å¤æ¸¸æˆçŠ¶æ€
  if (targetState) {
    board = targetState.board.slice();
    nextPlayer = targetState.nextPlayer;
    gameOver = targetState.gameOver;
  } else {
    // æ¢å¤åˆ°åˆå§‹çŠ¶æ€
    board = Array(CELLS).fill(null);
    nextPlayer = 'X';
    gameOver = false;
  }
  
  isAiThinking = false;
  updateStatusDisplay();
  renderBoard();
  estimateAndRender();
  updateUndoButton();
}

// æ›´æ–°æ‚”æ£‹æŒ‰é’®çŠ¶æ€
function updateUndoButton() {
  const undoBtn = document.getElementById('undo');
  undoBtn.disabled = gameHistory.length === 0;
}

function renderBoard() {
  boardEl.innerHTML = '';
  for (let i=0;i<CELLS;i++){
    const div = document.createElement('div');
    div.className = 'cell' + (board[i] ? ' '+board[i] : '');
    div.textContent = board[i] ?? '';
    if (!gameOver && !board[i] && !isAiThinking) {
      div.addEventListener('click', () => handleMove(i), {once:true});
    } else {
      div.classList.add('disabled');
    }
    boardEl.appendChild(div);
  }
  updateStatusDisplay();
}

function getAvailableMoves(b){ const m=[]; for(let i=0;i<b.length;i++) if(b[i]==null) m.push(i); return m; }

function getWinner(b) {
  for (const line of LINES) {
    const first = b[line[0]];
    if (!first) continue;
    let ok = true;
    for (let j=1;j<line.length;j++) if (b[line[j]] !== first) { ok=false; break; }
    if (ok) return {winner: first, line: line};
  }
  return null;
}

function isGameOver(b){ return !!getWinner(b) || getAvailableMoves(b).length===0; }

// æ›´æ–°çŠ¶æ€æ˜¾ç¤º
function updateStatusDisplay() {
  if (gameOver) return;
  
  let displayText = '';
  if (gameMode === 'ai') {
    if (nextPlayer === aiPlayer) {
      displayText = currentLanguage === 'zh' ? `AI (${nextPlayer}) æ€è€ƒä¸­...` : `AI (${nextPlayer}) thinking...`;
      isAiThinking = true;
    } else {
      const turnText = currentLanguage === 'zh' ? 'è½®åˆ°' : 'Turn';
      const playerText = currentLanguage === 'zh' ? 'ç©å®¶' : 'Player';
      displayText = `${turnText}: <b>${nextPlayer}</b> (${playerText})`;
      isAiThinking = false;
    }
  } else {
    const turnText = currentLanguage === 'zh' ? 'è½®åˆ°' : 'Turn';
    displayText = `${turnText}: <b>${nextPlayer}</b>`;
    isAiThinking = false;
  }
  statusEl.innerHTML = displayText;
}

// AIè¯„åˆ†å‡½æ•°
function evaluatePosition(board, player) {
  const opponent = player === 'X' ? 'O' : 'X';
  let score = 0;
  
  // æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„5è¿çº¿
  for (const line of LINES) {
    let playerCount = 0;
    let opponentCount = 0;
    let emptyCount = 0;
    
    for (const pos of line) {
      if (board[pos] === player) playerCount++;
      else if (board[pos] === opponent) opponentCount++;
      else emptyCount++;
    }
    
    // å¦‚æœè¿™æ¡çº¿æœ‰å¯¹æ‰‹çš„å­ï¼Œå°±ä¸èƒ½å½¢æˆå·±æ–¹çš„5è¿
    if (opponentCount > 0 && playerCount > 0) continue;
    
    // å·±æ–¹çš„è¿å­è¯„åˆ†
    if (playerCount > 0 && opponentCount === 0) {
      if (playerCount === 5) score += 100000;
      else if (playerCount === 4) score += 10000;
      else if (playerCount === 3) score += 1000;
      else if (playerCount === 2) score += 100;
      else if (playerCount === 1) score += 10;
    }
    
    // å¯¹æ‰‹çš„è¿å­å¨èƒè¯„åˆ†ï¼ˆéœ€è¦é˜»æ­¢ï¼‰
    if (opponentCount > 0 && playerCount === 0) {
      if (opponentCount === 4) score -= 50000; // å¿…é¡»é˜»æ­¢å¯¹æ‰‹4è¿
      else if (opponentCount === 3) score -= 5000;
      else if (opponentCount === 2) score -= 500;
      else if (opponentCount === 1) score -= 50;
    }
  }
  
  return score;
}

// AIé€‰æ‹©æœ€ä½³ç§»åŠ¨ï¼ˆæ ¹æ®éš¾åº¦è°ƒæ•´ï¼‰
function getBestMove(board, player) {
  const moves = getAvailableMoves(board);
  if (moves.length === 0) return null;
  
  // æ ¹æ®éš¾åº¦å†³å®šç­–ç•¥
  switch (aiDifficulty) {
    case 'easy':
      return getEasyMove(board, player, moves);
    case 'medium':
      return getMediumMove(board, player, moves);
    case 'hard':
      return getHardMove(board, player, moves);
    default:
      return getMediumMove(board, player, moves);
  }
}

// ç®€å•éš¾åº¦ï¼š60%æœ€ä½³ç§»åŠ¨ï¼Œ40%éšæœºç§»åŠ¨
function getEasyMove(board, player, moves) {
  // å¦‚æœæ˜¯ç¬¬ä¸€æ­¥ï¼Œ85%æ¦‚ç‡é€‰æ‹©ä¸­å¿ƒï¼Œ15%éšæœº
  if (moves.length === CELLS) {
    if (Math.random() < 0.85) {
      const center = Math.floor(SIZE / 2) * SIZE + Math.floor(SIZE / 2);
      return center;
    } else {
      return moves[Math.floor(Math.random() * moves.length)];
    }
  }
  
  // æ€»æ˜¯æ£€æŸ¥è·èƒœæœºä¼š
  for (const move of moves) {
    const testBoard = board.slice();
    testBoard[move] = player;
    const winResult = getWinner(testBoard);
    if (winResult && winResult.winner === player) {
      return move; // å¦‚æœèƒ½è·èƒœï¼Œæ€»æ˜¯é€‰æ‹©è·èƒœ
    }
  }
  
  // 90%æ¦‚ç‡æ£€æŸ¥é˜»æ­¢å¯¹æ‰‹è·èƒœ
  if (Math.random() < 0.9) {
    const opponent = player === 'X' ? 'O' : 'X';
    for (const move of moves) {
      const testBoard = board.slice();
      testBoard[move] = opponent;
      const opponentWin = getWinner(testBoard);
      if (opponentWin && opponentWin.winner === opponent) {
        return move; // é˜»æ­¢å¯¹æ‰‹è·èƒœ
      }
    }
  }
  
  // 60%æ¦‚ç‡é€‰æ‹©æœ€ä½³ç§»åŠ¨ï¼Œ40%éšæœºç§»åŠ¨
  if (Math.random() < 0.6) {
    return getHardMove(board, player, moves);
  } else {
    return moves[Math.floor(Math.random() * moves.length)];
  }
}

// ä¸­ç­‰éš¾åº¦ï¼š70%æœ€ä½³ç§»åŠ¨ï¼Œ30%æ¬¡ä¼˜ç§»åŠ¨
function getMediumMove(board, player, moves) {
  // å¦‚æœæ˜¯ç¬¬ä¸€æ­¥ï¼Œé€‰æ‹©ä¸­å¿ƒä½ç½®
  if (moves.length === CELLS) {
    const center = Math.floor(SIZE / 2) * SIZE + Math.floor(SIZE / 2);
    return center;
  }
  
  // æ€»æ˜¯æ£€æŸ¥è·èƒœæœºä¼š
  for (const move of moves) {
    const testBoard = board.slice();
    testBoard[move] = player;
    const winResult = getWinner(testBoard);
    if (winResult && winResult.winner === player) {
      return move;
    }
  }
  
  // æ€»æ˜¯é˜»æ­¢å¯¹æ‰‹è·èƒœ
  const opponent = player === 'X' ? 'O' : 'X';
  for (const move of moves) {
    const testBoard = board.slice();
    testBoard[move] = opponent;
    const opponentWin = getWinner(testBoard);
    if (opponentWin && opponentWin.winner === opponent) {
      return move;
    }
  }
  
  // 70%æ¦‚ç‡é€‰æ‹©æœ€ä½³ç§»åŠ¨
  if (Math.random() < 0.7) {
    return getHardMove(board, player, moves);
  } else {
    // 30%æ¦‚ç‡é€‰æ‹©æ¬¡ä¼˜ç§»åŠ¨ï¼ˆéšæœºé€‰æ‹©å‰50%çš„å¥½ç§»åŠ¨ï¼‰
    const scoredMoves = moves.map(move => {
      const testBoard = board.slice();
      testBoard[move] = player;
      const score = evaluatePosition(testBoard, player);
      const row = Math.floor(move / SIZE);
      const col = move % SIZE;
      const centerRow = Math.floor(SIZE / 2);
      const centerCol = Math.floor(SIZE / 2);
      const distanceFromCenter = Math.abs(row - centerRow) + Math.abs(col - centerCol);
      const positionBonus = Math.max(0, 10 - distanceFromCenter);
      return { move, score: score + positionBonus };
    });
    
    scoredMoves.sort((a, b) => b.score - a.score);
    const topMoves = scoredMoves.slice(0, Math.max(1, Math.floor(scoredMoves.length * 0.5)));
    return topMoves[Math.floor(Math.random() * topMoves.length)].move;
  }
}

// å›°éš¾éš¾åº¦ï¼šæ€»æ˜¯é€‰æ‹©æœ€ä½³ç§»åŠ¨
function getHardMove(board, player, moves) {
  let bestMove = moves[0];
  let bestScore = -Infinity;
  
  // å¦‚æœæ˜¯ç¬¬ä¸€æ­¥ï¼Œé€‰æ‹©ä¸­å¿ƒä½ç½®
  if (moves.length === CELLS) {
    const center = Math.floor(SIZE / 2) * SIZE + Math.floor(SIZE / 2);
    return center;
  }
  
  // ä¸ºæ¯ä¸ªå¯èƒ½çš„ç§»åŠ¨è®¡ç®—è¯„åˆ†
  for (const move of moves) {
    const testBoard = board.slice();
    testBoard[move] = player;
    
    // æ£€æŸ¥æ˜¯å¦èƒ½ç›´æ¥è·èƒœ
    const winResult = getWinner(testBoard);
    if (winResult && winResult.winner === player) {
      return move; // ç›´æ¥è·èƒœ
    }
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦é˜»æ­¢å¯¹æ‰‹è·èƒœ
    const opponent = player === 'X' ? 'O' : 'X';
    testBoard[move] = opponent;
    const opponentWin = getWinner(testBoard);
    if (opponentWin && opponentWin.winner === opponent) {
      testBoard[move] = player; // æ¢å¤ä¸ºAIçš„ç§»åŠ¨
      const score = evaluatePosition(testBoard, player) + 60000; // é˜»æ­¢å¯¹æ‰‹è·èƒœçš„é«˜åˆ†
      if (score > bestScore) {
        bestScore = score;
        bestMove = move;
      }
      continue;
    }
    
    // æ­£å¸¸è¯„åˆ†
    testBoard[move] = player;
    const score = evaluatePosition(testBoard, player);
    
    // ä½ç½®å¥–åŠ±ï¼šæ›´é è¿‘ä¸­å¿ƒçš„ä½ç½®è·å¾—é¢å¤–åˆ†æ•°
    const row = Math.floor(move / SIZE);
    const col = move % SIZE;
    const centerRow = Math.floor(SIZE / 2);
    const centerCol = Math.floor(SIZE / 2);
    const distanceFromCenter = Math.abs(row - centerRow) + Math.abs(col - centerCol);
    const positionBonus = Math.max(0, 10 - distanceFromCenter);
    
    const finalScore = score + positionBonus;
    
    if (finalScore > bestScore) {
      bestScore = finalScore;
      bestMove = move;
    }
  }
  
  return bestMove;
}

// AIæ‰§è¡Œç§»åŠ¨
function makeAiMove() {
  if (gameOver || nextPlayer !== aiPlayer) return;
  
  isAiThinking = true;
  updateStatusDisplay();
  renderBoard();
  
  // ä½¿ç”¨setTimeoutæ¥æ¨¡æ‹ŸAIæ€è€ƒæ—¶é—´ï¼ˆæ ¹æ®éš¾åº¦è°ƒæ•´ï¼‰
  let thinkingTime;
  switch (aiDifficulty) {
    case 'easy':
      thinkingTime = 500 + Math.random() * 400; // 500-900ms
      break;
    case 'medium':
      thinkingTime = 600 + Math.random() * 400; // 600-1000ms
      break;
    case 'hard':
      thinkingTime = 800 + Math.random() * 500; // 800-1300ms
      break;
    default:
      thinkingTime = 600 + Math.random() * 400;
  }
  
  setTimeout(() => {
    const bestMove = getBestMove(board, aiPlayer);
    if (bestMove !== null) {
      handleMove(bestMove, true);
    }
    isAiThinking = false;
  }, thinkingTime);
}

function handleMove(idx, isAiMove = false){
  if (gameOver || board[idx] || (gameMode === 'ai' && !isAiMove && nextPlayer === aiPlayer)) return;
  
  // ä¿å­˜å½“å‰çŠ¶æ€åˆ°å†å²è®°å½•
  gameHistory.push({
    board: board.slice(), // åˆ›å»ºæ£‹ç›˜å‰¯æœ¬
    nextPlayer: nextPlayer,
    gameOver: gameOver
  });
  
  board[idx] = nextPlayer;
  const winnerResult = getWinner(board);
  if (winnerResult) {
    gameOver = true;
    const winnerText = gameMode === 'ai' && winnerResult.winner === aiPlayer ? 'AI' : winnerResult.winner;
    const gameOverText = currentLanguage === 'zh' ? 'æ¸¸æˆç»“æŸ' : 'Game Over';
    const winsText = currentLanguage === 'zh' ? 'è·èƒœï¼' : 'Wins!';
    statusEl.innerHTML = `${gameOverText}: <b>${winnerText}</b> ${winsText}`;
    createConfetti();
    highlightWinningCells(winnerResult.line);
  } else if (getAvailableMoves(board).length===0) {
    gameOver = true;
    const gameOverText = currentLanguage === 'zh' ? 'æ¸¸æˆç»“æŸ' : 'Game Over';
    const drawText = currentLanguage === 'zh' ? 'å¹³å±€ï¼' : 'Draw!';
    statusEl.textContent = `${gameOverText}: ${drawText}`;
  } else {
    nextPlayer = nextPlayer==='X' ? 'O' : 'X';
    updateStatusDisplay();
  }
  renderBoard();
  estimateAndRender();
  updateUndoButton();
  
  // åœ¨äººæœºæ¨¡å¼ä¸‹ï¼Œå¦‚æœè½®åˆ°AIï¼Œè‡ªåŠ¨æ‰§è¡ŒAIç§»åŠ¨
  if (gameMode === 'ai' && !gameOver && nextPlayer === aiPlayer) {
    setTimeout(() => makeAiMove(), 500); // å»¶è¿Ÿ500msè®©ç”¨æˆ·çœ‹åˆ°å˜åŒ–
  }
}

function playRandomGame(b, player){
  while(true){
    const winner = getWinner(b);
    if (winner) return winner.winner;
    const moves = getAvailableMoves(b);
    if (moves.length===0) return null;
    const move = moves[(Math.random()*moves.length)|0];
    b[move] = player;
    player = player==='X' ? 'O' : 'X';
  }
}

function simulateWinRate(b, player, simulations=1500){
  let xWins=0, oWins=0, draws=0;
  for (let i=0;i<simulations;i++){
    const copy = b.slice();
    const res = playRandomGame(copy, player);
    if (res==='X') xWins++;
    else if (res==='O') oWins++;
    else draws++;
  }
  return {
    x: xWins/simulations,
    o: oWins/simulations,
    d: draws/simulations
  };
}

function estimateAndRender(){
  const sims = +simsInput.value;
  simsVal.textContent = sims;
  const t0 = performance.now();
  if (gameOver){
    const w = getWinner(board);
    const rates = w ? (w.winner==='X'?{x:1,o:0,d:0}:{x:0,o:1,d:0}) : {x:0,o:0,d:1};
    updateBars(rates, 0);
    return;
  }
  requestAnimationFrame(()=>{
    const rates = simulateWinRate(board, nextPlayer, sims);
    const t1 = performance.now();
    updateBars(rates, t1 - t0);
  });
}

function updateBars(rates, ms){
  const toPct = v => Math.round(v*100);
  const xPct = toPct(rates.x) + '%';
  const oPct = toPct(rates.o) + '%';
  const dPct = toPct(rates.d) + '%';
  
  xPctEl.textContent = xPct;
  oPctEl.textContent = oPct;
  dPctEl.textContent = dPct;
  xBar.style.width = (rates.x*100) + '%';
  oBar.style.width = (rates.o*100) + '%';
  dBar.style.width = (rates.d*100) + '%';
  timeInfo.textContent = ms ? `${Math.round(ms)}ms` : '';
  
  // æ›´æ–°å¸¦è¯­è¨€çš„æ ‡ç­¾
  if (currentLanguage === 'zh') {
    document.getElementById('xWinLabel').innerHTML = `Xèƒœ: <b id="xPct">${xPct}</b>`;
    document.getElementById('oWinLabel').innerHTML = `Oèƒœ: <b id="oPct">${oPct}</b>`;
    document.getElementById('drawLabel').innerHTML = `å¹³å±€: <b id="dPct">${dPct}</b>`;
  } else {
    document.getElementById('xWinLabel').innerHTML = `X Win: <b id="xPct">${xPct}</b>`;
    document.getElementById('oWinLabel').innerHTML = `O Win: <b id="oPct">${oPct}</b>`;
    document.getElementById('drawLabel').innerHTML = `Draw: <b id="dPct">${dPct}</b>`;
  }
}

simsInput.addEventListener('input', ()=>{ simsVal.textContent = simsInput.value; });
document.getElementById('rerun').addEventListener('click', estimateAndRender);
document.getElementById('undo').addEventListener('click', undoMove);
document.getElementById('reset').addEventListener('click', ()=>{
  board = Array(CELLS).fill(null);
  nextPlayer = 'X';
  gameOver = false;
  gameHistory = []; // æ¸…ç©ºå†å²è®°å½•
  isAiThinking = false;
  updateStatusDisplay();
  renderBoard();
  estimateAndRender();
  updateUndoButton();
});

// æ¸¸æˆæ¨¡å¼åˆ‡æ¢äº‹ä»¶
gameModeSelect.addEventListener('change', (e) => {
  gameMode = e.target.value;
  
  // æ˜¾ç¤ºæˆ–éšè—éš¾åº¦é€‰æ‹©å™¨
  if (gameMode === 'ai') {
    difficultyRow.style.display = 'flex';
  } else {
    difficultyRow.style.display = 'none';
  }
  
  // é‡ç½®æ¸¸æˆ
  board = Array(CELLS).fill(null);
  nextPlayer = 'X';
  gameOver = false;
  gameHistory = [];
  isAiThinking = false;
  
  // åœ¨AIæ¨¡å¼ä¸‹ï¼ŒAIæ€»æ˜¯æ‰®æ¼”O
  aiPlayer = 'O';
  
  updateStatusDisplay();
  renderBoard();
  estimateAndRender();
  updateUndoButton();
});

// AIéš¾åº¦åˆ‡æ¢äº‹ä»¶
aiDifficultySelect.addEventListener('change', (e) => {
  aiDifficulty = e.target.value;
  // ä¸éœ€è¦é‡ç½®æ¸¸æˆï¼Œåªæ˜¯æ”¹å˜AIç­–ç•¥
});
themeToggle.addEventListener('click', toggleTheme);
languageToggle.addEventListener('click', toggleLanguage);

renderBoard();
estimateAndRender();
updateUndoButton();

// åˆå§‹åŒ–æ¸¸æˆæ¨¡å¼
gameMode = gameModeSelect.value;
aiDifficulty = aiDifficultySelect.value;

// æ ¹æ®åˆå§‹æ¸¸æˆæ¨¡å¼æ˜¾ç¤ºæˆ–éšè—éš¾åº¦é€‰æ‹©å™¨
if (gameMode === 'ai') {
  difficultyRow.style.display = 'flex';
} else {
  difficultyRow.style.display = 'none';
}

// åˆå§‹åŒ–ä¸»é¢˜ä¸ºæµ…è‰²æ¨¡å¼
document.documentElement.setAttribute('data-theme', 'light');

// åˆå§‹åŒ–è¯­è¨€ä¸ºä¸­æ–‡
currentLanguage = 'zh';
updateTexts();
updateStatusDisplay();

</script>
</body>
</html>
